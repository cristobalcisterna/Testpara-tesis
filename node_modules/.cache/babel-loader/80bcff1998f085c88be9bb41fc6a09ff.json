{"ast":null,"code":"function _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/**\n  * vee-validate v4.6.6\n  * (c) 2022 Abdelrahman Awad\n  * @license MIT\n  */\nimport { inject, getCurrentInstance, warn as warn$1, ref, unref, computed, reactive, watch, onUnmounted, nextTick, onMounted, provide, isRef, onBeforeUnmount, defineComponent, toRef, resolveDynamicComponent, h, watchEffect, markRaw } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\nfunction isCallable(fn) {\n  return typeof fn === 'function';\n}\n\nfunction isNullOrUndefined(value) {\n  return value === null || value === undefined;\n}\n\nvar isObject = function isObject(obj) {\n  return obj !== null && !!obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n};\n\nfunction isIndex(value) {\n  return Number(value) >= 0;\n}\n\nfunction toNumber(value) {\n  var n = parseFloat(value);\n  return isNaN(n) ? value : n;\n}\n\nvar RULES = {};\n/**\r\n * Adds a custom validator to the list of validation rules.\r\n */\n\nfunction defineRule(id, validator) {\n  // makes sure new rules are properly formatted.\n  guardExtend(id, validator);\n  RULES[id] = validator;\n}\n/**\r\n * Gets an already defined rule\r\n */\n\n\nfunction resolveRule(id) {\n  return RULES[id];\n}\n/**\r\n * Guards from extension violations.\r\n */\n\n\nfunction guardExtend(id, validator) {\n  if (isCallable(validator)) {\n    return;\n  }\n\n  throw new Error(\"Extension Error: The validator '\".concat(id, \"' must be a function.\"));\n}\n\nvar FormContextKey = Symbol('vee-validate-form');\nvar FieldContextKey = Symbol('vee-validate-field-instance');\nvar IS_ABSENT = Symbol('Default empty value');\n\nfunction isLocator(value) {\n  return isCallable(value) && !!value.__locatorRef;\n}\n\nfunction isYupValidator(value) {\n  return !!value && isCallable(value.validate);\n}\n\nfunction hasCheckedAttr(type) {\n  return type === 'checkbox' || type === 'radio';\n}\n\nfunction isContainerValue(value) {\n  return isObject(value) || Array.isArray(value);\n}\n/**\r\n * True if the value is an empty object or array\r\n */\n\n\nfunction isEmptyContainer(value) {\n  if (Array.isArray(value)) {\n    return value.length === 0;\n  }\n\n  return isObject(value) && Object.keys(value).length === 0;\n}\n/**\r\n * Checks if the path opted out of nested fields using `[fieldName]` syntax\r\n */\n\n\nfunction isNotNestedPath(path) {\n  return /^\\[.+\\]$/i.test(path);\n}\n/**\r\n * Checks if an element is a native HTML5 multi-select input element\r\n */\n\n\nfunction isNativeMultiSelect(el) {\n  return isNativeSelect(el) && el.multiple;\n}\n/**\r\n * Checks if an element is a native HTML5 select input element\r\n */\n\n\nfunction isNativeSelect(el) {\n  return el.tagName === 'SELECT';\n}\n/**\r\n * Checks if a tag name with attrs object will render a native multi-select element\r\n */\n\n\nfunction isNativeMultiSelectNode(tag, attrs) {\n  // The falsy value array is the values that Vue won't add the `multiple` prop if it has one of these values\n  var hasTruthyBindingValue = ![false, null, undefined, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);\n  return tag === 'select' && 'multiple' in attrs && hasTruthyBindingValue;\n}\n/**\r\n * Checks if a node should have a `:value` binding or not\r\n *\r\n * These nodes should not have a value binding\r\n * For files, because they are not reactive\r\n * For multi-selects because the value binding will reset the value\r\n */\n\n\nfunction shouldHaveValueBinding(tag, attrs) {\n  return !isNativeMultiSelectNode(tag, attrs) && attrs.type !== 'file' && !hasCheckedAttr(attrs.type);\n}\n\nfunction isFormSubmitEvent(evt) {\n  return isEvent(evt) && evt.target && 'submit' in evt.target;\n}\n\nfunction isEvent(evt) {\n  if (!evt) {\n    return false;\n  }\n\n  if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {\n    return true;\n  } // this is for IE and Cypress #3161\n\n  /* istanbul ignore next */\n\n\n  if (evt && evt.srcElement) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isPropPresent(obj, prop) {\n  return prop in obj && obj[prop] !== IS_ABSENT;\n} // do not edit .js files directly - edit src/index.jst\n\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && _typeof(a) == 'object' && _typeof(b) == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n\n\n  return a !== a && b !== b;\n};\n\nfunction cleanupNonNestedPath(path) {\n  if (isNotNestedPath(path)) {\n    return path.replace(/\\[|\\]/gi, '');\n  }\n\n  return path;\n}\n\nfunction getFromPath(object, path, fallback) {\n  if (!object) {\n    return fallback;\n  }\n\n  if (isNotNestedPath(path)) {\n    return object[cleanupNonNestedPath(path)];\n  }\n\n  var resolvedValue = (path || '').split(/\\.|\\[(\\d+)\\]/).filter(Boolean).reduce(function (acc, propKey) {\n    if (isContainerValue(acc) && propKey in acc) {\n      return acc[propKey];\n    }\n\n    return fallback;\n  }, object);\n  return resolvedValue;\n}\n/**\r\n * Sets a nested property value in a path, creates the path properties if it doesn't exist\r\n */\n\n\nfunction setInPath(object, path, value) {\n  if (isNotNestedPath(path)) {\n    object[cleanupNonNestedPath(path)] = value;\n    return;\n  }\n\n  var keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\n  var acc = object;\n\n  for (var i = 0; i < keys.length; i++) {\n    // Last key, set it\n    if (i === keys.length - 1) {\n      acc[keys[i]] = value;\n      return;\n    } // Key does not exist, create a container for it\n\n\n    if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {\n      // container can be either an object or an array depending on the next key if it exists\n      acc[keys[i]] = isIndex(keys[i + 1]) ? [] : {};\n    }\n\n    acc = acc[keys[i]];\n  }\n}\n\nfunction unset(object, key) {\n  if (Array.isArray(object) && isIndex(key)) {\n    object.splice(Number(key), 1);\n    return;\n  }\n\n  if (isObject(object)) {\n    delete object[key];\n  }\n}\n/**\r\n * Removes a nested property from object\r\n */\n\n\nfunction unsetPath(object, path) {\n  if (isNotNestedPath(path)) {\n    delete object[cleanupNonNestedPath(path)];\n    return;\n  }\n\n  var keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\n  var acc = object;\n\n  for (var i = 0; i < keys.length; i++) {\n    // Last key, unset it\n    if (i === keys.length - 1) {\n      unset(acc, keys[i]);\n      break;\n    } // Key does not exist, exit\n\n\n    if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {\n      break;\n    }\n\n    acc = acc[keys[i]];\n  }\n\n  var pathValues = keys.map(function (_, idx) {\n    return getFromPath(object, keys.slice(0, idx).join('.'));\n  });\n\n  for (var _i = pathValues.length - 1; _i >= 0; _i--) {\n    if (!isEmptyContainer(pathValues[_i])) {\n      continue;\n    }\n\n    if (_i === 0) {\n      unset(object, keys[0]);\n      continue;\n    }\n\n    unset(pathValues[_i - 1], keys[_i - 1]);\n  }\n}\n/**\r\n * A typed version of Object.keys\r\n */\n\n\nfunction keysOf(record) {\n  return Object.keys(record);\n} // Uses same component provide as its own injections\n// Due to changes in https://github.com/vuejs/vue-next/pull/2424\n\n\nfunction injectWithSelf(symbol) {\n  var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  var vm = getCurrentInstance();\n  return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject(symbol, def);\n}\n\nfunction warn(message) {\n  warn$1(\"[vee-validate]: \".concat(message));\n}\n/**\r\n * Ensures we deal with a singular field value\r\n */\n\n\nfunction normalizeField(field) {\n  if (Array.isArray(field)) {\n    return field[0];\n  }\n\n  return field;\n}\n\nfunction resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {\n  if (Array.isArray(currentValue)) {\n    var newVal = _toConsumableArray(currentValue); // Use isEqual since checked object values can possibly fail the equality check #3883\n\n\n    var idx = newVal.findIndex(function (v) {\n      return fastDeepEqual(v, checkedValue);\n    });\n    idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);\n    return newVal;\n  }\n\n  return fastDeepEqual(currentValue, checkedValue) ? uncheckedValue : checkedValue;\n}\n/**\r\n * Creates a throttled function that only invokes the provided function (`func`) at most once per within a given number of milliseconds\r\n * (`limit`)\r\n */\n\n\nfunction throttle(func, limit) {\n  var inThrottle;\n  var lastResult;\n  return function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    var context = this;\n\n    if (!inThrottle) {\n      inThrottle = true;\n      setTimeout(function () {\n        return inThrottle = false;\n      }, limit);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      lastResult = func.apply(context, args);\n    }\n\n    return lastResult;\n  };\n}\n\nfunction debounceAsync(inner) {\n  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var timer = null;\n  var resolves = [];\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    // Run the function after a certain amount of time\n    if (timer) {\n      window.clearTimeout(timer);\n    }\n\n    timer = window.setTimeout(function () {\n      // Get the result of the inner function, then apply it to the resolve function of\n      // each promise that has been created since the last time the inner function was run\n      var result = inner.apply(void 0, args);\n      resolves.forEach(function (r) {\n        return r(result);\n      });\n      resolves = [];\n    }, ms);\n    return new Promise(function (resolve) {\n      return resolves.push(resolve);\n    });\n  };\n}\n\nfunction applyModelModifiers(value, modifiers) {\n  if (!isObject(modifiers)) {\n    return value;\n  }\n\n  if (modifiers.number) {\n    return toNumber(value);\n  }\n\n  return value;\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nvar normalizeChildren = function normalizeChildren(tag, context, slotProps) {\n  if (!context.slots[\"default\"]) {\n    return context.slots[\"default\"];\n  }\n\n  if (typeof tag === 'string' || !tag) {\n    return context.slots[\"default\"](slotProps());\n  }\n\n  return {\n    \"default\": function _default() {\n      var _a, _b;\n\n      return (_b = (_a = context.slots)[\"default\"]) === null || _b === void 0 ? void 0 : _b.call(_a, slotProps());\n    }\n  };\n};\n/**\r\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\r\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\r\n */\n\n\nfunction getBoundValue(el) {\n  if (hasValueBinding(el)) {\n    return el._value;\n  }\n\n  return undefined;\n}\n/**\r\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\r\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\r\n */\n\n\nfunction hasValueBinding(el) {\n  return '_value' in el;\n}\n\nfunction normalizeEventValue(value) {\n  if (!isEvent(value)) {\n    return value;\n  }\n\n  var input = value.target; // Vue sets the current bound value on `_value` prop\n  // for checkboxes it it should fetch the value binding type as is (boolean instead of string)\n\n  if (hasCheckedAttr(input.type) && hasValueBinding(input)) {\n    return getBoundValue(input);\n  }\n\n  if (input.type === 'file' && input.files) {\n    var files = Array.from(input.files);\n    return input.multiple ? files : files[0];\n  }\n\n  if (isNativeMultiSelect(input)) {\n    return Array.from(input.options).filter(function (opt) {\n      return opt.selected && !opt.disabled;\n    }).map(getBoundValue);\n  } // makes sure we get the actual `option` bound value\n  // #3440\n\n\n  if (isNativeSelect(input)) {\n    var selectedOption = Array.from(input.options).find(function (opt) {\n      return opt.selected;\n    });\n    return selectedOption ? getBoundValue(selectedOption) : input.value;\n  }\n\n  return input.value;\n}\n/**\r\n * Normalizes the given rules expression.\r\n */\n\n\nfunction normalizeRules(rules) {\n  var acc = {};\n  Object.defineProperty(acc, '_$$isNormalized', {\n    value: true,\n    writable: false,\n    enumerable: false,\n    configurable: false\n  });\n\n  if (!rules) {\n    return acc;\n  } // Object is already normalized, skip.\n\n\n  if (isObject(rules) && rules._$$isNormalized) {\n    return rules;\n  }\n\n  if (isObject(rules)) {\n    return Object.keys(rules).reduce(function (prev, curr) {\n      var params = normalizeParams(rules[curr]);\n\n      if (rules[curr] !== false) {\n        prev[curr] = buildParams(params);\n      }\n\n      return prev;\n    }, acc);\n  }\n  /* istanbul ignore if */\n\n\n  if (typeof rules !== 'string') {\n    return acc;\n  }\n\n  return rules.split('|').reduce(function (prev, rule) {\n    var parsedRule = parseRule(rule);\n\n    if (!parsedRule.name) {\n      return prev;\n    }\n\n    prev[parsedRule.name] = buildParams(parsedRule.params);\n    return prev;\n  }, acc);\n}\n/**\r\n * Normalizes a rule param.\r\n */\n\n\nfunction normalizeParams(params) {\n  if (params === true) {\n    return [];\n  }\n\n  if (Array.isArray(params)) {\n    return params;\n  }\n\n  if (isObject(params)) {\n    return params;\n  }\n\n  return [params];\n}\n\nfunction buildParams(provided) {\n  var mapValueToLocator = function mapValueToLocator(value) {\n    // A target param using interpolation\n    if (typeof value === 'string' && value[0] === '@') {\n      return createLocator(value.slice(1));\n    }\n\n    return value;\n  };\n\n  if (Array.isArray(provided)) {\n    return provided.map(mapValueToLocator);\n  } // #3073\n\n\n  if (provided instanceof RegExp) {\n    return [provided];\n  }\n\n  return Object.keys(provided).reduce(function (prev, key) {\n    prev[key] = mapValueToLocator(provided[key]);\n    return prev;\n  }, {});\n}\n/**\r\n * Parses a rule string expression.\r\n */\n\n\nvar parseRule = function parseRule(rule) {\n  var params = [];\n  var name = rule.split(':')[0];\n\n  if (rule.includes(':')) {\n    params = rule.split(':').slice(1).join(':').split(',');\n  }\n\n  return {\n    name: name,\n    params: params\n  };\n};\n\nfunction createLocator(value) {\n  var locator = function locator(crossTable) {\n    var val = getFromPath(crossTable, value) || crossTable[value];\n    return val;\n  };\n\n  locator.__locatorRef = value;\n  return locator;\n}\n\nfunction extractLocators(params) {\n  if (Array.isArray(params)) {\n    return params.filter(isLocator);\n  }\n\n  return keysOf(params).filter(function (key) {\n    return isLocator(params[key]);\n  }).map(function (key) {\n    return params[key];\n  });\n}\n\nvar DEFAULT_CONFIG = {\n  generateMessage: function generateMessage(_ref) {\n    var field = _ref.field;\n    return \"\".concat(field, \" is not valid.\");\n  },\n  bails: true,\n  validateOnBlur: true,\n  validateOnChange: true,\n  validateOnInput: false,\n  validateOnModelUpdate: true\n};\nvar currentConfig = Object.assign({}, DEFAULT_CONFIG);\n\nvar getConfig = function getConfig() {\n  return currentConfig;\n};\n\nvar setConfig = function setConfig(newConf) {\n  currentConfig = Object.assign(Object.assign({}, currentConfig), newConf);\n};\n\nvar configure = setConfig;\n/**\r\n * Validates a value against the rules.\r\n */\n\nfunction validate(_x, _x2) {\n  return _validate2.apply(this, arguments);\n}\n/**\r\n * Starts the validation process.\r\n */\n\n\nfunction _validate2() {\n  _validate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(value, rules) {\n    var options,\n        shouldBail,\n        field,\n        result,\n        errors,\n        _args11 = arguments;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            options = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : {};\n            shouldBail = options === null || options === void 0 ? void 0 : options.bails;\n            field = {\n              name: (options === null || options === void 0 ? void 0 : options.name) || '{field}',\n              rules: rules,\n              bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,\n              formData: (options === null || options === void 0 ? void 0 : options.values) || {}\n            };\n            _context11.next = 5;\n            return _validate(field, value);\n\n          case 5:\n            result = _context11.sent;\n            errors = result.errors;\n            return _context11.abrupt(\"return\", {\n              errors: errors,\n              valid: !errors.length\n            });\n\n          case 8:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _validate2.apply(this, arguments);\n}\n\nfunction _validate(_x3, _x4) {\n  return _validate3.apply(this, arguments);\n}\n/**\r\n * Handles yup validation\r\n */\n\n\nfunction _validate3() {\n  _validate3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(field, value) {\n    var ctx, pipeline, _length, _errors2, i, rule, result, isValid, message, normalizedContext, errors, rulesKeys, length, _i2, _rule, _result;\n\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            if (!isYupValidator(field.rules)) {\n              _context12.next = 2;\n              break;\n            }\n\n            return _context12.abrupt(\"return\", validateFieldWithYup(value, field.rules, {\n              bails: field.bails\n            }));\n\n          case 2:\n            if (!(isCallable(field.rules) || Array.isArray(field.rules))) {\n              _context12.next = 24;\n              break;\n            }\n\n            ctx = {\n              field: field.name,\n              form: field.formData,\n              value: value\n            }; // Normalize the pipeline\n\n            pipeline = Array.isArray(field.rules) ? field.rules : [field.rules];\n            _length = pipeline.length;\n            _errors2 = [];\n            i = 0;\n\n          case 8:\n            if (!(i < _length)) {\n              _context12.next = 23;\n              break;\n            }\n\n            rule = pipeline[i];\n            _context12.next = 12;\n            return rule(value, ctx);\n\n          case 12:\n            result = _context12.sent;\n            isValid = typeof result !== 'string' && result;\n\n            if (!isValid) {\n              _context12.next = 16;\n              break;\n            }\n\n            return _context12.abrupt(\"continue\", 20);\n\n          case 16:\n            message = typeof result === 'string' ? result : _generateFieldError(ctx);\n\n            _errors2.push(message);\n\n            if (!field.bails) {\n              _context12.next = 20;\n              break;\n            }\n\n            return _context12.abrupt(\"return\", {\n              errors: _errors2\n            });\n\n          case 20:\n            i++;\n            _context12.next = 8;\n            break;\n\n          case 23:\n            return _context12.abrupt(\"return\", {\n              errors: _errors2\n            });\n\n          case 24:\n            normalizedContext = Object.assign(Object.assign({}, field), {\n              rules: normalizeRules(field.rules)\n            });\n            errors = [];\n            rulesKeys = Object.keys(normalizedContext.rules);\n            length = rulesKeys.length;\n            _i2 = 0;\n\n          case 29:\n            if (!(_i2 < length)) {\n              _context12.next = 41;\n              break;\n            }\n\n            _rule = rulesKeys[_i2];\n            _context12.next = 33;\n            return _test(normalizedContext, value, {\n              name: _rule,\n              params: normalizedContext.rules[_rule]\n            });\n\n          case 33:\n            _result = _context12.sent;\n\n            if (!_result.error) {\n              _context12.next = 38;\n              break;\n            }\n\n            errors.push(_result.error);\n\n            if (!field.bails) {\n              _context12.next = 38;\n              break;\n            }\n\n            return _context12.abrupt(\"return\", {\n              errors: errors\n            });\n\n          case 38:\n            _i2++;\n            _context12.next = 29;\n            break;\n\n          case 41:\n            return _context12.abrupt(\"return\", {\n              errors: errors\n            });\n\n          case 42:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _validate3.apply(this, arguments);\n}\n\nfunction validateFieldWithYup(_x5, _x6, _x7) {\n  return _validateFieldWithYup.apply(this, arguments);\n}\n/**\r\n * Tests a single input value against a rule.\r\n */\n\n\nfunction _validateFieldWithYup() {\n  _validateFieldWithYup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(value, validator, opts) {\n    var _a, errors;\n\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return validator.validate(value, {\n              abortEarly: (_a = opts.bails) !== null && _a !== void 0 ? _a : true\n            }).then(function () {\n              return [];\n            })[\"catch\"](function (err) {\n              // Yup errors have a name prop one them.\n              // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n              if (err.name === 'ValidationError') {\n                return err.errors;\n              } // re-throw the error so we don't hide it\n\n\n              throw err;\n            });\n\n          case 2:\n            errors = _context13.sent;\n            return _context13.abrupt(\"return\", {\n              errors: errors\n            });\n\n          case 4:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _validateFieldWithYup.apply(this, arguments);\n}\n\nfunction _test(_x8, _x9, _x10) {\n  return _test2.apply(this, arguments);\n}\n/**\r\n * Generates error messages.\r\n */\n\n\nfunction _test2() {\n  _test2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(field, value, rule) {\n    var validator, params, ctx, result;\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            validator = resolveRule(rule.name);\n\n            if (validator) {\n              _context14.next = 3;\n              break;\n            }\n\n            throw new Error(\"No such validator '\".concat(rule.name, \"' exists.\"));\n\n          case 3:\n            params = fillTargetValues(rule.params, field.formData);\n            ctx = {\n              field: field.name,\n              value: value,\n              form: field.formData,\n              rule: Object.assign(Object.assign({}, rule), {\n                params: params\n              })\n            };\n            _context14.next = 7;\n            return validator(value, params, ctx);\n\n          case 7:\n            result = _context14.sent;\n\n            if (!(typeof result === 'string')) {\n              _context14.next = 10;\n              break;\n            }\n\n            return _context14.abrupt(\"return\", {\n              error: result\n            });\n\n          case 10:\n            return _context14.abrupt(\"return\", {\n              error: result ? undefined : _generateFieldError(ctx)\n            });\n\n          case 11:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return _test2.apply(this, arguments);\n}\n\nfunction _generateFieldError(fieldCtx) {\n  var message = getConfig().generateMessage;\n\n  if (!message) {\n    return 'Field is invalid';\n  }\n\n  return message(fieldCtx);\n}\n\nfunction fillTargetValues(params, crossTable) {\n  var normalize = function normalize(value) {\n    if (isLocator(value)) {\n      return value(crossTable);\n    }\n\n    return value;\n  };\n\n  if (Array.isArray(params)) {\n    return params.map(normalize);\n  }\n\n  return Object.keys(params).reduce(function (acc, param) {\n    acc[param] = normalize(params[param]);\n    return acc;\n  }, {});\n}\n\nfunction validateYupSchema(_x11, _x12) {\n  return _validateYupSchema.apply(this, arguments);\n}\n\nfunction _validateYupSchema() {\n  _validateYupSchema = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(schema, values) {\n    var errorObjects, results, errors, _iterator5, _step5, error, messages;\n\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            _context15.next = 2;\n            return schema.validate(values, {\n              abortEarly: false\n            }).then(function () {\n              return [];\n            })[\"catch\"](function (err) {\n              // Yup errors have a name prop one them.\n              // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n              if (err.name !== 'ValidationError') {\n                throw err;\n              } // list of aggregated errors\n\n\n              return err.inner || [];\n            });\n\n          case 2:\n            errorObjects = _context15.sent;\n            results = {};\n            errors = {};\n            _iterator5 = _createForOfIteratorHelper(errorObjects);\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                error = _step5.value;\n                messages = error.errors;\n                results[error.path] = {\n                  valid: !messages.length,\n                  errors: messages\n                };\n\n                if (messages.length) {\n                  errors[error.path] = messages[0];\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n\n            return _context15.abrupt(\"return\", {\n              valid: !errorObjects.length,\n              results: results,\n              errors: errors\n            });\n\n          case 8:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return _validateYupSchema.apply(this, arguments);\n}\n\nfunction validateObjectSchema(_x13, _x14, _x15) {\n  return _validateObjectSchema.apply(this, arguments);\n}\n\nfunction _validateObjectSchema() {\n  _validateObjectSchema = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(schema, values, opts) {\n    var paths, validations, isAllValid, validationResults, results, errors, _iterator6, _step6, result;\n\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            paths = keysOf(schema);\n            validations = paths.map( /*#__PURE__*/function () {\n              var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(path) {\n                var _a, _b, _c, fieldResult;\n\n                return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n                  while (1) {\n                    switch (_context16.prev = _context16.next) {\n                      case 0:\n                        _context16.next = 2;\n                        return validate(getFromPath(values, path), schema[path], {\n                          name: ((_a = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a === void 0 ? void 0 : _a[path]) || path,\n                          values: values,\n                          bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true\n                        });\n\n                      case 2:\n                        fieldResult = _context16.sent;\n                        return _context16.abrupt(\"return\", Object.assign(Object.assign({}, fieldResult), {\n                          path: path\n                        }));\n\n                      case 4:\n                      case \"end\":\n                        return _context16.stop();\n                    }\n                  }\n                }, _callee16);\n              }));\n\n              return function (_x22) {\n                return _ref8.apply(this, arguments);\n              };\n            }());\n            isAllValid = true;\n            _context17.next = 5;\n            return Promise.all(validations);\n\n          case 5:\n            validationResults = _context17.sent;\n            results = {};\n            errors = {};\n            _iterator6 = _createForOfIteratorHelper(validationResults);\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                result = _step6.value;\n                results[result.path] = {\n                  valid: result.valid,\n                  errors: result.errors\n                };\n\n                if (!result.valid) {\n                  isAllValid = false;\n                  errors[result.path] = result.errors[0];\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            return _context17.abrupt(\"return\", {\n              valid: isAllValid,\n              results: results,\n              errors: errors\n            });\n\n          case 11:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17);\n  }));\n  return _validateObjectSchema.apply(this, arguments);\n}\n\nfunction set(obj, key, val) {\n  if (_typeof(val.value) === 'object') val.value = klona(val.value);\n\n  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n    Object.defineProperty(obj, key, val);\n  } else obj[key] = val.value;\n}\n\nfunction klona(x) {\n  if (_typeof(x) !== 'object') return x;\n  var i = 0,\n      k,\n      list,\n      tmp,\n      str = Object.prototype.toString.call(x);\n\n  if (str === '[object Object]') {\n    tmp = Object.create(x.__proto__ || null);\n  } else if (str === '[object Array]') {\n    tmp = Array(x.length);\n  } else if (str === '[object Set]') {\n    tmp = new Set();\n    x.forEach(function (val) {\n      tmp.add(klona(val));\n    });\n  } else if (str === '[object Map]') {\n    tmp = new Map();\n    x.forEach(function (val, key) {\n      tmp.set(klona(key), klona(val));\n    });\n  } else if (str === '[object Date]') {\n    tmp = new Date(+x);\n  } else if (str === '[object RegExp]') {\n    tmp = new RegExp(x.source, x.flags);\n  } else if (str === '[object DataView]') {\n    tmp = new x.constructor(klona(x.buffer));\n  } else if (str === '[object ArrayBuffer]') {\n    tmp = x.slice(0);\n  } else if (str.slice(-6) === 'Array]') {\n    // ArrayBuffer.isView(x)\n    // ~> `new` bcuz `Buffer.slice` => ref\n    tmp = new x.constructor(x);\n  }\n\n  if (tmp) {\n    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {\n      set(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n    }\n\n    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {\n      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k]) continue;\n      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n    }\n  }\n\n  return tmp || x;\n}\n\nvar es6 = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && _typeof(a) == 'object' && _typeof(b) == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    if (a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n\n      var _iterator = _createForOfIteratorHelper(a.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          i = _step.value;\n          if (!b.has(i[0])) return false;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(a.entries()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          i = _step2.value;\n          if (!equal(i[1], b.get(i[0]))) return false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return true;\n    }\n\n    if (a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n\n      var _iterator3 = _createForOfIteratorHelper(a.entries()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          i = _step3.value;\n          if (!b.has(i[0])) return false;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (a[i] !== b[i]) return false;\n      }\n\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n\n\n  return a !== a && b !== b;\n};\n\nvar ID_COUNTER = 0;\n\nfunction useFieldState(path, init) {\n  var _useFieldValue2 = _useFieldValue(path, init.modelValue, !init.standalone),\n      value = _useFieldValue2.value,\n      initialValue = _useFieldValue2.initialValue,\n      setInitialValue = _useFieldValue2.setInitialValue;\n\n  var _useFieldErrors2 = _useFieldErrors(path, !init.standalone),\n      errorMessage = _useFieldErrors2.errorMessage,\n      errors = _useFieldErrors2.errors,\n      setErrors = _useFieldErrors2.setErrors;\n\n  var meta = _useFieldMeta(value, initialValue, errors);\n\n  var id = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;\n\n  function setState(state) {\n    var _a;\n\n    if ('value' in state) {\n      value.value = state.value;\n    }\n\n    if ('errors' in state) {\n      setErrors(state.errors);\n    }\n\n    if ('touched' in state) {\n      meta.touched = (_a = state.touched) !== null && _a !== void 0 ? _a : meta.touched;\n    }\n\n    if ('initialValue' in state) {\n      setInitialValue(state.initialValue);\n    }\n  }\n\n  return {\n    id: id,\n    path: path,\n    value: value,\n    initialValue: initialValue,\n    meta: meta,\n    errors: errors,\n    errorMessage: errorMessage,\n    setState: setState\n  };\n}\n/**\r\n * Creates the field value and resolves the initial value\r\n */\n\n\nfunction _useFieldValue(path, modelValue) {\n  var shouldInjectForm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var form = shouldInjectForm === true ? injectWithSelf(FormContextKey, undefined) : undefined;\n  var modelRef = ref(unref(modelValue));\n\n  function resolveInitialValue() {\n    if (!form) {\n      return unref(modelRef);\n    }\n\n    return getFromPath(form.meta.value.initialValues, unref(path), unref(modelRef));\n  }\n\n  function setInitialValue(value) {\n    if (!form) {\n      modelRef.value = value;\n      return;\n    }\n\n    form.stageInitialValue(unref(path), value, true);\n  }\n\n  var initialValue = computed(resolveInitialValue); // if no form is associated, use a regular ref.\n\n  if (!form) {\n    var _value = ref(resolveInitialValue());\n\n    return {\n      value: _value,\n      initialValue: initialValue,\n      setInitialValue: setInitialValue\n    };\n  } // to set the initial value, first check if there is a current value, if there is then use it.\n  // otherwise use the configured initial value if it exists.\n  // prioritize model value over form values\n  // #3429\n\n\n  var currentValue = modelValue ? unref(modelValue) : getFromPath(form.values, unref(path), unref(initialValue));\n  form.stageInitialValue(unref(path), currentValue, true); // otherwise use a computed setter that triggers the `setFieldValue`\n\n  var value = computed({\n    get: function get() {\n      return getFromPath(form.values, unref(path));\n    },\n    set: function set(newVal) {\n      form.setFieldValue(unref(path), newVal);\n    }\n  });\n  return {\n    value: value,\n    initialValue: initialValue,\n    setInitialValue: setInitialValue\n  };\n}\n/**\r\n * Creates meta flags state and some associated effects with them\r\n */\n\n\nfunction _useFieldMeta(currentValue, initialValue, errors) {\n  var meta = reactive({\n    touched: false,\n    pending: false,\n    valid: true,\n    validated: !!unref(errors).length,\n    initialValue: computed(function () {\n      return unref(initialValue);\n    }),\n    dirty: computed(function () {\n      return !es6(unref(currentValue), unref(initialValue));\n    })\n  });\n  watch(errors, function (value) {\n    meta.valid = !value.length;\n  }, {\n    immediate: true,\n    flush: 'sync'\n  });\n  return meta;\n}\n/**\r\n * Creates the error message state for the field state\r\n */\n\n\nfunction _useFieldErrors(path, shouldInjectForm) {\n  var form = shouldInjectForm ? injectWithSelf(FormContextKey, undefined) : undefined;\n\n  function normalizeErrors(messages) {\n    if (!messages) {\n      return [];\n    }\n\n    return Array.isArray(messages) ? messages : [messages];\n  }\n\n  if (!form) {\n    var _errors = ref([]);\n\n    return {\n      errors: _errors,\n      errorMessage: computed(function () {\n        return _errors.value[0];\n      }),\n      setErrors: function setErrors(messages) {\n        _errors.value = normalizeErrors(messages);\n      }\n    };\n  }\n\n  var errors = computed(function () {\n    return form.errorBag.value[unref(path)] || [];\n  });\n  return {\n    errors: errors,\n    errorMessage: computed(function () {\n      return errors.value[0];\n    }),\n    setErrors: function setErrors(messages) {\n      form.setFieldErrorBag(unref(path), normalizeErrors(messages));\n    }\n  };\n}\n\nfunction installDevtoolsPlugin(app) {\n  if (process.env.NODE_ENV !== 'production') {\n    setupDevtoolsPlugin({\n      id: 'vee-validate-devtools-plugin',\n      label: 'VeeValidate Plugin',\n      packageName: 'vee-validate',\n      homepage: 'https://vee-validate.logaretm.com/v4',\n      app: app,\n      logo: 'https://vee-validate.logaretm.com/v4/logo.png'\n    }, setupApiHooks);\n  }\n}\n\nvar DEVTOOLS_FORMS = {};\nvar DEVTOOLS_FIELDS = {};\nvar API;\nvar refreshInspector = throttle(function () {\n  setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return nextTick();\n\n          case 2:\n            API === null || API === void 0 ? void 0 : API.sendInspectorState(INSPECTOR_ID);\n            API === null || API === void 0 ? void 0 : API.sendInspectorTree(INSPECTOR_ID);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), 100);\n}, 100);\n\nfunction registerFormWithDevTools(form) {\n  var vm = getCurrentInstance();\n\n  if (!API) {\n    var app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;\n\n    if (!app) {\n      return;\n    }\n\n    installDevtoolsPlugin(app);\n  }\n\n  DEVTOOLS_FORMS[form.formId] = Object.assign({}, form);\n  DEVTOOLS_FORMS[form.formId]._vm = vm;\n  onUnmounted(function () {\n    delete DEVTOOLS_FORMS[form.formId];\n    refreshInspector();\n  });\n  refreshInspector();\n}\n\nfunction registerSingleFieldWithDevtools(field) {\n  var vm = getCurrentInstance();\n\n  if (!API) {\n    var app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;\n\n    if (!app) {\n      return;\n    }\n\n    installDevtoolsPlugin(app);\n  }\n\n  DEVTOOLS_FIELDS[field.id] = Object.assign({}, field);\n  DEVTOOLS_FIELDS[field.id]._vm = vm;\n  onUnmounted(function () {\n    delete DEVTOOLS_FIELDS[field.id];\n    refreshInspector();\n  });\n  refreshInspector();\n}\n\nvar INSPECTOR_ID = 'vee-validate-inspector';\nvar COLORS = {\n  error: 0xbd4b4b,\n  success: 0x06d77b,\n  unknown: 0x54436b,\n  white: 0xffffff,\n  black: 0x000000,\n  blue: 0x035397,\n  purple: 0xb980f0,\n  orange: 0xf5a962,\n  gray: 0xbbbfca\n};\nvar SELECTED_NODE = null;\n\nfunction setupApiHooks(api) {\n  API = api;\n  api.addInspector({\n    id: INSPECTOR_ID,\n    icon: 'rule',\n    label: 'vee-validate',\n    noSelectionText: 'Select a vee-validate node to inspect',\n    actions: [{\n      icon: 'done_outline',\n      tooltip: 'Validate selected item',\n      action: function () {\n        var _action = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var result;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (SELECTED_NODE) {\n                    _context2.next = 3;\n                    break;\n                  }\n\n                  console.error('There is not a valid selected vee-validate node or component');\n                  return _context2.abrupt(\"return\");\n\n                case 3:\n                  _context2.next = 5;\n                  return SELECTED_NODE.validate();\n\n                case 5:\n                  result = _context2.sent;\n                  console.log(result);\n\n                case 7:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        function action() {\n          return _action.apply(this, arguments);\n        }\n\n        return action;\n      }()\n    }, {\n      icon: 'delete_sweep',\n      tooltip: 'Clear validation state of the selected item',\n      action: function action() {\n        if (!SELECTED_NODE) {\n          console.error('There is not a valid selected vee-validate node or component');\n          return;\n        }\n\n        if ('id' in SELECTED_NODE) {\n          SELECTED_NODE.resetField();\n          return;\n        }\n\n        SELECTED_NODE.resetForm();\n      }\n    }]\n  });\n  api.on.getInspectorTree(function (payload) {\n    if (payload.inspectorId !== INSPECTOR_ID) {\n      return;\n    }\n\n    var forms = Object.values(DEVTOOLS_FORMS);\n    var fields = Object.values(DEVTOOLS_FIELDS);\n    payload.rootNodes = [].concat(_toConsumableArray(forms.map(mapFormForDevtoolsInspector)), _toConsumableArray(fields.map(function (field) {\n      return mapFieldForDevtoolsInspector(field);\n    })));\n  });\n  api.on.getInspectorState(function (payload, ctx) {\n    if (payload.inspectorId !== INSPECTOR_ID || ctx.currentTab !== \"custom-inspector:\".concat(INSPECTOR_ID)) {\n      return;\n    }\n\n    var _decodeNodeId = decodeNodeId(payload.nodeId),\n        form = _decodeNodeId.form,\n        field = _decodeNodeId.field,\n        type = _decodeNodeId.type;\n\n    if (form && type === 'form') {\n      payload.state = buildFormState(form);\n      SELECTED_NODE = form;\n      return;\n    }\n\n    if (field && type === 'field') {\n      payload.state = buildFieldState(field);\n      SELECTED_NODE = field;\n      return;\n    }\n\n    SELECTED_NODE = null;\n  });\n}\n\nfunction mapFormForDevtoolsInspector(form) {\n  var _getTagTheme = getTagTheme(form),\n      textColor = _getTagTheme.textColor,\n      bgColor = _getTagTheme.bgColor;\n\n  var formTreeNodes = {};\n  Object.values(form.fieldsByPath.value).forEach(function (field) {\n    var fieldInstance = Array.isArray(field) ? field[0] : field;\n\n    if (!fieldInstance) {\n      return;\n    }\n\n    setInPath(formTreeNodes, unref(fieldInstance.name), mapFieldForDevtoolsInspector(fieldInstance, form));\n  });\n\n  function buildFormTree(tree) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    var key = _toConsumableArray(path).pop();\n\n    if ('id' in tree) {\n      return Object.assign(Object.assign({}, tree), {\n        label: key || tree.label\n      });\n    }\n\n    if (isObject(tree)) {\n      return {\n        id: \"\".concat(path.join('.')),\n        label: key || '',\n        children: Object.keys(tree).map(function (key) {\n          return buildFormTree(tree[key], [].concat(_toConsumableArray(path), [key]));\n        })\n      };\n    }\n\n    if (Array.isArray(tree)) {\n      return {\n        id: \"\".concat(path.join('.')),\n        label: \"\".concat(key, \"[]\"),\n        children: tree.map(function (c, idx) {\n          return buildFormTree(c, [].concat(_toConsumableArray(path), [String(idx)]));\n        })\n      };\n    }\n\n    return {\n      id: '',\n      label: '',\n      children: []\n    };\n  }\n\n  var _buildFormTree = buildFormTree(formTreeNodes),\n      children = _buildFormTree.children;\n\n  return {\n    id: encodeNodeId(form),\n    label: 'Form',\n    children: children,\n    tags: [{\n      label: 'Form',\n      textColor: textColor,\n      backgroundColor: bgColor\n    }, {\n      label: \"\".concat(Object.keys(form.fieldsByPath.value).length, \" fields\"),\n      textColor: COLORS.white,\n      backgroundColor: COLORS.unknown\n    }]\n  };\n}\n\nfunction mapFieldForDevtoolsInspector(field, form) {\n  var fieldInstance = normalizeField(field);\n\n  var _getTagTheme2 = getTagTheme(fieldInstance),\n      textColor = _getTagTheme2.textColor,\n      bgColor = _getTagTheme2.bgColor;\n\n  var isGroup = Array.isArray(field) && field.length > 1;\n  return {\n    id: encodeNodeId(form, fieldInstance, !isGroup),\n    label: unref(fieldInstance.name),\n    children: Array.isArray(field) ? field.map(function (fieldItem) {\n      return mapFieldForDevtoolsInspector(fieldItem, form);\n    }) : undefined,\n    tags: [isGroup ? undefined : {\n      label: 'Field',\n      textColor: textColor,\n      backgroundColor: bgColor\n    }, !form ? {\n      label: 'Standalone',\n      textColor: COLORS.black,\n      backgroundColor: COLORS.gray\n    } : undefined, !isGroup && fieldInstance.type === 'checkbox' ? {\n      label: 'Checkbox',\n      textColor: COLORS.white,\n      backgroundColor: COLORS.blue\n    } : undefined, !isGroup && fieldInstance.type === 'radio' ? {\n      label: 'Radio',\n      textColor: COLORS.white,\n      backgroundColor: COLORS.purple\n    } : undefined, isGroup ? {\n      label: 'Group',\n      textColor: COLORS.black,\n      backgroundColor: COLORS.orange\n    } : undefined].filter(Boolean)\n  };\n}\n\nfunction encodeNodeId(form, field) {\n  var encodeIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var fieldPath = form ? unref(field === null || field === void 0 ? void 0 : field.name) : field === null || field === void 0 ? void 0 : field.id;\n  var fieldGroup = fieldPath ? form === null || form === void 0 ? void 0 : form.fieldsByPath.value[fieldPath] : undefined;\n  var idx;\n\n  if (encodeIndex && field && Array.isArray(fieldGroup)) {\n    idx = fieldGroup.indexOf(field);\n  }\n\n  var idObject = {\n    f: form === null || form === void 0 ? void 0 : form.formId,\n    ff: fieldPath,\n    idx: idx,\n    type: field ? 'field' : 'form'\n  };\n  return btoa(JSON.stringify(idObject));\n}\n\nfunction decodeNodeId(nodeId) {\n  try {\n    var idObject = JSON.parse(atob(nodeId));\n    var form = DEVTOOLS_FORMS[idObject.f];\n\n    if (!form && idObject.ff) {\n      var field = DEVTOOLS_FIELDS[idObject.ff];\n\n      if (!field) {\n        return {};\n      }\n\n      return {\n        type: idObject.type,\n        field: field\n      };\n    }\n\n    if (!form) {\n      return {};\n    }\n\n    var fieldGroup = form.fieldsByPath.value[idObject.ff];\n    return {\n      type: idObject.type,\n      form: form,\n      field: Array.isArray(fieldGroup) ? fieldGroup[idObject.idx || 0] : fieldGroup\n    };\n  } catch (err) {// console.error(`Devtools: [vee-validate] Failed to parse node id ${nodeId}`);\n  }\n\n  return {};\n}\n\nfunction buildFieldState(field) {\n  var errors = field.errors,\n      meta = field.meta,\n      value = field.value;\n  return {\n    'Field state': [{\n      key: 'errors',\n      value: errors.value\n    }, {\n      key: 'initialValue',\n      value: meta.initialValue\n    }, {\n      key: 'currentValue',\n      value: value.value\n    }, {\n      key: 'touched',\n      value: meta.touched\n    }, {\n      key: 'dirty',\n      value: meta.dirty\n    }, {\n      key: 'valid',\n      value: meta.valid\n    }]\n  };\n}\n\nfunction buildFormState(form) {\n  var errorBag = form.errorBag,\n      meta = form.meta,\n      values = form.values,\n      isSubmitting = form.isSubmitting,\n      submitCount = form.submitCount;\n  return {\n    'Form state': [{\n      key: 'submitCount',\n      value: submitCount.value\n    }, {\n      key: 'isSubmitting',\n      value: isSubmitting.value\n    }, {\n      key: 'touched',\n      value: meta.value.touched\n    }, {\n      key: 'dirty',\n      value: meta.value.dirty\n    }, {\n      key: 'valid',\n      value: meta.value.valid\n    }, {\n      key: 'initialValues',\n      value: meta.value.initialValues\n    }, {\n      key: 'currentValues',\n      value: values\n    }, {\n      key: 'errors',\n      value: keysOf(errorBag.value).reduce(function (acc, key) {\n        var _a;\n\n        var message = (_a = errorBag.value[key]) === null || _a === void 0 ? void 0 : _a[0];\n\n        if (message) {\n          acc[key] = message;\n        }\n\n        return acc;\n      }, {})\n    }]\n  };\n}\n/**\r\n * Resolves the tag color based on the form state\r\n */\n\n\nfunction getTagTheme(fieldOrForm) {\n  // const fallbackColors = {\n  //   bgColor: COLORS.unknown,\n  //   textColor: COLORS.white,\n  // };\n  var isValid = 'id' in fieldOrForm ? fieldOrForm.meta.valid : fieldOrForm.meta.value.valid;\n  return {\n    bgColor: isValid ? COLORS.success : COLORS.error,\n    textColor: isValid ? COLORS.black : COLORS.white\n  };\n}\n/**\r\n * Creates a field composite.\r\n */\n\n\nfunction useField(name, rules, opts) {\n  if (hasCheckedAttr(opts === null || opts === void 0 ? void 0 : opts.type)) {\n    return useCheckboxField(name, rules, opts);\n  }\n\n  return _useField(name, rules, opts);\n}\n\nfunction _useField(name, rules, opts) {\n  var _normalizeOptions = normalizeOptions(unref(name), opts),\n      modelValue = _normalizeOptions.initialValue,\n      validateOnMount = _normalizeOptions.validateOnMount,\n      bails = _normalizeOptions.bails,\n      type = _normalizeOptions.type,\n      checkedValue = _normalizeOptions.checkedValue,\n      label = _normalizeOptions.label,\n      validateOnValueUpdate = _normalizeOptions.validateOnValueUpdate,\n      uncheckedValue = _normalizeOptions.uncheckedValue,\n      standalone = _normalizeOptions.standalone,\n      keepValueOnUnmount = _normalizeOptions.keepValueOnUnmount,\n      modelPropName = _normalizeOptions.modelPropName,\n      syncVModel = _normalizeOptions.syncVModel;\n\n  var form = !standalone ? injectWithSelf(FormContextKey) : undefined; // a flag indicating if the field is about to be removed/unmounted.\n\n  var markedForRemoval = false;\n\n  var _useFieldState = useFieldState(name, {\n    modelValue: modelValue,\n    standalone: standalone\n  }),\n      id = _useFieldState.id,\n      value = _useFieldState.value,\n      initialValue = _useFieldState.initialValue,\n      meta = _useFieldState.meta,\n      setState = _useFieldState.setState,\n      errors = _useFieldState.errors,\n      errorMessage = _useFieldState.errorMessage;\n\n  if (syncVModel) {\n    useVModel({\n      value: value,\n      prop: modelPropName,\n      handleChange: handleChange\n    });\n  }\n  /**\r\n   * Handles common onBlur meta update\r\n   */\n\n\n  var handleBlur = function handleBlur() {\n    meta.touched = true;\n  };\n\n  var normalizedRules = computed(function () {\n    var rulesValue = unref(rules);\n    var schema = unref(form === null || form === void 0 ? void 0 : form.schema);\n\n    if (schema && !isYupValidator(schema)) {\n      rulesValue = extractRuleFromSchema(schema, unref(name)) || rulesValue;\n    }\n\n    if (isYupValidator(rulesValue) || isCallable(rulesValue) || Array.isArray(rulesValue)) {\n      return rulesValue;\n    }\n\n    return normalizeRules(rulesValue);\n  });\n\n  function validateCurrentValue(_x16) {\n    return _validateCurrentValue.apply(this, arguments);\n  }\n\n  function _validateCurrentValue() {\n    _validateCurrentValue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(mode) {\n      var _a, _b;\n\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(form === null || form === void 0 ? void 0 : form.validateSchema)) {\n                _context3.next = 14;\n                break;\n              }\n\n              _context3.next = 3;\n              return form.validateSchema(mode);\n\n            case 3:\n              _context3.t1 = unref(name);\n              _context3.t2 = _a = _context3.sent.results[_context3.t1];\n              _context3.t0 = _context3.t2 !== null;\n\n              if (!_context3.t0) {\n                _context3.next = 8;\n                break;\n              }\n\n              _context3.t0 = _a !== void 0;\n\n            case 8:\n              if (!_context3.t0) {\n                _context3.next = 12;\n                break;\n              }\n\n              _context3.t3 = _a;\n              _context3.next = 13;\n              break;\n\n            case 12:\n              _context3.t3 = {\n                valid: true,\n                errors: []\n              };\n\n            case 13:\n              return _context3.abrupt(\"return\", _context3.t3);\n\n            case 14:\n              return _context3.abrupt(\"return\", validate(value.value, normalizedRules.value, {\n                name: unref(label) || unref(name),\n                values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},\n                bails: bails\n              }));\n\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _validateCurrentValue.apply(this, arguments);\n  }\n\n  function validateWithStateMutation() {\n    return _validateWithStateMutation.apply(this, arguments);\n  }\n\n  function _validateWithStateMutation() {\n    _validateWithStateMutation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      var result;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              meta.pending = true;\n              meta.validated = true;\n              _context4.next = 4;\n              return validateCurrentValue('validated-only');\n\n            case 4:\n              result = _context4.sent;\n\n              if (markedForRemoval) {\n                result.valid = true;\n                result.errors = [];\n              }\n\n              setState({\n                errors: result.errors\n              });\n              meta.pending = false;\n              return _context4.abrupt(\"return\", result);\n\n            case 9:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _validateWithStateMutation.apply(this, arguments);\n  }\n\n  function validateValidStateOnly() {\n    return _validateValidStateOnly.apply(this, arguments);\n  }\n\n  function _validateValidStateOnly() {\n    _validateValidStateOnly = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n      var result;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return validateCurrentValue('silent');\n\n            case 2:\n              result = _context5.sent;\n\n              if (markedForRemoval) {\n                result.valid = true;\n              }\n\n              meta.valid = result.valid;\n              return _context5.abrupt(\"return\", result);\n\n            case 6:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    return _validateValidStateOnly.apply(this, arguments);\n  }\n\n  function validate$1(opts) {\n    if (!(opts === null || opts === void 0 ? void 0 : opts.mode) || (opts === null || opts === void 0 ? void 0 : opts.mode) === 'force') {\n      return validateWithStateMutation();\n    }\n\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'validated-only') {\n      return validateWithStateMutation();\n    }\n\n    return validateValidStateOnly();\n  } // Common input/change event handler\n\n\n  function handleChange(e) {\n    var shouldValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var newValue = normalizeEventValue(e);\n    value.value = newValue;\n\n    if (!validateOnValueUpdate && shouldValidate) {\n      validateWithStateMutation();\n    }\n  } // Runs the initial validation\n\n\n  onMounted(function () {\n    if (validateOnMount) {\n      return validateWithStateMutation();\n    } // validate self initially if no form was handling this\n    // forms should have their own initial silent validation run to make things more efficient\n\n\n    if (!form || !form.validateSchema) {\n      validateValidStateOnly();\n    }\n  });\n\n  function setTouched(isTouched) {\n    meta.touched = isTouched;\n  }\n\n  var unwatchValue;\n\n  function watchValue() {\n    unwatchValue = watch(value, function (val, oldVal) {\n      if (es6(val, oldVal)) {\n        return;\n      }\n\n      var validateFn = validateOnValueUpdate ? validateWithStateMutation : validateValidStateOnly;\n      validateFn();\n    }, {\n      deep: true\n    });\n  }\n\n  watchValue();\n\n  function resetField(state) {\n    var _a;\n\n    unwatchValue === null || unwatchValue === void 0 ? void 0 : unwatchValue();\n    var newValue = state && 'value' in state ? state.value : initialValue.value;\n    setState({\n      value: klona(newValue),\n      initialValue: klona(newValue),\n      touched: (_a = state === null || state === void 0 ? void 0 : state.touched) !== null && _a !== void 0 ? _a : false,\n      errors: (state === null || state === void 0 ? void 0 : state.errors) || []\n    });\n    meta.pending = false;\n    meta.validated = false;\n    validateValidStateOnly(); // need to watch at next tick to avoid triggering the value watcher\n\n    nextTick(function () {\n      watchValue();\n    });\n  }\n\n  function setValue(newValue) {\n    value.value = newValue;\n  }\n\n  function setErrors(errors) {\n    setState({\n      errors: Array.isArray(errors) ? errors : [errors]\n    });\n  }\n\n  var field = {\n    id: id,\n    name: name,\n    label: label,\n    value: value,\n    meta: meta,\n    errors: errors,\n    errorMessage: errorMessage,\n    type: type,\n    checkedValue: checkedValue,\n    uncheckedValue: uncheckedValue,\n    bails: bails,\n    keepValueOnUnmount: keepValueOnUnmount,\n    resetField: resetField,\n    handleReset: function handleReset() {\n      return resetField();\n    },\n    validate: validate$1,\n    handleChange: handleChange,\n    handleBlur: handleBlur,\n    setState: setState,\n    setTouched: setTouched,\n    setErrors: setErrors,\n    setValue: setValue\n  };\n  provide(FieldContextKey, field);\n\n  if (isRef(rules) && typeof unref(rules) !== 'function') {\n    watch(rules, function (value, oldValue) {\n      if (es6(value, oldValue)) {\n        return;\n      }\n\n      meta.validated ? validateWithStateMutation() : validateValidStateOnly();\n    }, {\n      deep: true\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    field._vm = getCurrentInstance();\n    watch(function () {\n      return Object.assign(Object.assign({\n        errors: errors.value\n      }, meta), {\n        value: value.value\n      });\n    }, refreshInspector, {\n      deep: true\n    });\n\n    if (!form) {\n      registerSingleFieldWithDevtools(field);\n    }\n  } // if no associated form return the field API immediately\n\n\n  if (!form) {\n    return field;\n  } // associate the field with the given form\n\n\n  form.register(field);\n  onBeforeUnmount(function () {\n    markedForRemoval = true;\n    form.unregister(field);\n  }); // extract cross-field dependencies in a computed prop\n\n  var dependencies = computed(function () {\n    var rulesVal = normalizedRules.value; // is falsy, a function schema or a yup schema\n\n    if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal) || Array.isArray(rulesVal)) {\n      return {};\n    }\n\n    return Object.keys(rulesVal).reduce(function (acc, rule) {\n      var deps = extractLocators(rulesVal[rule]).map(function (dep) {\n        return dep.__locatorRef;\n      }).reduce(function (depAcc, depName) {\n        var depValue = getFromPath(form.values, depName) || form.values[depName];\n\n        if (depValue !== undefined) {\n          depAcc[depName] = depValue;\n        }\n\n        return depAcc;\n      }, {});\n      Object.assign(acc, deps);\n      return acc;\n    }, {});\n  }); // Adds a watcher that runs the validation whenever field dependencies change\n\n  watch(dependencies, function (deps, oldDeps) {\n    // Skip if no dependencies or if the field wasn't manipulated\n    if (!Object.keys(deps).length) {\n      return;\n    }\n\n    var shouldValidate = !es6(deps, oldDeps);\n\n    if (shouldValidate) {\n      meta.validated ? validateWithStateMutation() : validateValidStateOnly();\n    }\n  });\n  return field;\n}\n/**\r\n * Normalizes partial field options to include the full options\r\n */\n\n\nfunction normalizeOptions(name, opts) {\n  var defaults = function defaults() {\n    return {\n      initialValue: undefined,\n      validateOnMount: false,\n      bails: true,\n      rules: '',\n      label: name,\n      validateOnValueUpdate: true,\n      standalone: false,\n      keepValueOnUnmount: undefined,\n      modelPropName: 'modelValue',\n      syncVModel: true\n    };\n  };\n\n  if (!opts) {\n    return defaults();\n  } // TODO: Deprecate this in next major release\n\n\n  var checkedValue = 'valueProp' in opts ? opts.valueProp : opts.checkedValue;\n  return Object.assign(Object.assign(Object.assign({}, defaults()), opts || {}), {\n    checkedValue: checkedValue\n  });\n}\n/**\r\n * Extracts the validation rules from a schema\r\n */\n\n\nfunction extractRuleFromSchema(schema, fieldName) {\n  // no schema at all\n  if (!schema) {\n    return undefined;\n  } // there is a key on the schema object for this field\n\n\n  return schema[fieldName];\n}\n\nfunction useCheckboxField(name, rules, opts) {\n  var form = !(opts === null || opts === void 0 ? void 0 : opts.standalone) ? injectWithSelf(FormContextKey) : undefined;\n  var checkedValue = opts === null || opts === void 0 ? void 0 : opts.checkedValue;\n  var uncheckedValue = opts === null || opts === void 0 ? void 0 : opts.uncheckedValue;\n\n  function patchCheckboxApi(field) {\n    var handleChange = field.handleChange;\n    var checked = computed(function () {\n      var currentValue = unref(field.value);\n      var checkedVal = unref(checkedValue);\n      return Array.isArray(currentValue) ? currentValue.findIndex(function (v) {\n        return es6(v, checkedVal);\n      }) >= 0 : es6(checkedVal, currentValue);\n    });\n\n    function handleCheckboxChange(e) {\n      var shouldValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var _a;\n\n      if (checked.value === ((_a = e === null || e === void 0 ? void 0 : e.target) === null || _a === void 0 ? void 0 : _a.checked)) {\n        return;\n      }\n\n      var newValue = normalizeEventValue(e); // Single checkbox field without a form to toggle it's value\n\n      if (!form) {\n        newValue = resolveNextCheckboxValue(unref(field.value), unref(checkedValue), unref(uncheckedValue));\n      }\n\n      handleChange(newValue, shouldValidate);\n    }\n\n    return Object.assign(Object.assign({}, field), {\n      checked: checked,\n      checkedValue: checkedValue,\n      uncheckedValue: uncheckedValue,\n      handleChange: handleCheckboxChange\n    });\n  }\n\n  return patchCheckboxApi(_useField(name, rules, opts));\n}\n\nfunction useVModel(_ref3) {\n  var prop = _ref3.prop,\n      value = _ref3.value,\n      handleChange = _ref3.handleChange;\n  var vm = getCurrentInstance();\n  /* istanbul ignore next */\n\n  if (!vm) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('Failed to setup model events because `useField` was not called in setup.');\n    }\n\n    return;\n  }\n\n  var propName = prop || 'modelValue';\n  var emitName = \"update:\".concat(propName); // Component doesn't have a model prop setup (must be defined on the props)\n\n  if (!(propName in vm.props)) {\n    return;\n  }\n\n  watch(value, function (newValue) {\n    if (es6(newValue, getCurrentModelValue(vm, propName))) {\n      return;\n    }\n\n    vm.emit(emitName, newValue);\n  });\n  watch(function () {\n    return getCurrentModelValue(vm, propName);\n  }, function (propValue) {\n    if (propValue === IS_ABSENT && value.value === undefined) {\n      return;\n    }\n\n    var newValue = propValue === IS_ABSENT ? undefined : propValue;\n\n    if (es6(newValue, applyModelModifiers(value.value, vm.props.modelModifiers))) {\n      return;\n    }\n\n    handleChange(newValue);\n  });\n}\n\nfunction getCurrentModelValue(vm, propName) {\n  return vm.props[propName];\n}\n\nvar FieldImpl = defineComponent({\n  name: 'Field',\n  inheritAttrs: false,\n  props: {\n    as: {\n      type: [String, Object],\n      \"default\": undefined\n    },\n    name: {\n      type: String,\n      required: true\n    },\n    rules: {\n      type: [Object, String, Function],\n      \"default\": undefined\n    },\n    validateOnMount: {\n      type: Boolean,\n      \"default\": false\n    },\n    validateOnBlur: {\n      type: Boolean,\n      \"default\": undefined\n    },\n    validateOnChange: {\n      type: Boolean,\n      \"default\": undefined\n    },\n    validateOnInput: {\n      type: Boolean,\n      \"default\": undefined\n    },\n    validateOnModelUpdate: {\n      type: Boolean,\n      \"default\": undefined\n    },\n    bails: {\n      type: Boolean,\n      \"default\": function _default() {\n        return getConfig().bails;\n      }\n    },\n    label: {\n      type: String,\n      \"default\": undefined\n    },\n    uncheckedValue: {\n      type: null,\n      \"default\": undefined\n    },\n    modelValue: {\n      type: null,\n      \"default\": IS_ABSENT\n    },\n    modelModifiers: {\n      type: null,\n      \"default\": function _default() {\n        return {};\n      }\n    },\n    'onUpdate:modelValue': {\n      type: null,\n      \"default\": undefined\n    },\n    standalone: {\n      type: Boolean,\n      \"default\": false\n    },\n    keepValue: {\n      type: Boolean,\n      \"default\": undefined\n    }\n  },\n  setup: function setup(props, ctx) {\n    var rules = toRef(props, 'rules');\n    var name = toRef(props, 'name');\n    var label = toRef(props, 'label');\n    var uncheckedValue = toRef(props, 'uncheckedValue');\n    var keepValue = toRef(props, 'keepValue');\n\n    var _useField2 = useField(name, rules, {\n      validateOnMount: props.validateOnMount,\n      bails: props.bails,\n      standalone: props.standalone,\n      type: ctx.attrs.type,\n      initialValue: resolveInitialValue(props, ctx),\n      // Only for checkboxes and radio buttons\n      checkedValue: ctx.attrs.value,\n      uncheckedValue: uncheckedValue,\n      label: label,\n      validateOnValueUpdate: false,\n      keepValueOnUnmount: keepValue\n    }),\n        errors = _useField2.errors,\n        value = _useField2.value,\n        errorMessage = _useField2.errorMessage,\n        validateField = _useField2.validate,\n        handleChange = _useField2.handleChange,\n        handleBlur = _useField2.handleBlur,\n        setTouched = _useField2.setTouched,\n        resetField = _useField2.resetField,\n        handleReset = _useField2.handleReset,\n        meta = _useField2.meta,\n        checked = _useField2.checked,\n        setErrors = _useField2.setErrors; // If there is a v-model applied on the component we need to emit the `update:modelValue` whenever the value binding changes\n\n\n    var onChangeHandler = function handleChangeWithModel(e) {\n      var shouldValidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      handleChange(e, shouldValidate);\n      ctx.emit('update:modelValue', value.value);\n    };\n\n    var handleInput = function handleInput(e) {\n      if (!hasCheckedAttr(ctx.attrs.type)) {\n        value.value = normalizeEventValue(e);\n      }\n    };\n\n    var onInputHandler = function handleInputWithModel(e) {\n      handleInput(e);\n      ctx.emit('update:modelValue', value.value);\n    };\n\n    var fieldProps = computed(function () {\n      var _resolveValidationTri = resolveValidationTriggers(props),\n          validateOnInput = _resolveValidationTri.validateOnInput,\n          validateOnChange = _resolveValidationTri.validateOnChange,\n          validateOnBlur = _resolveValidationTri.validateOnBlur,\n          validateOnModelUpdate = _resolveValidationTri.validateOnModelUpdate;\n\n      var baseOnBlur = [handleBlur, ctx.attrs.onBlur, validateOnBlur ? validateField : undefined].filter(Boolean);\n      var baseOnInput = [function (e) {\n        return onChangeHandler(e, validateOnInput);\n      }, ctx.attrs.onInput].filter(Boolean);\n      var baseOnChange = [function (e) {\n        return onChangeHandler(e, validateOnChange);\n      }, ctx.attrs.onChange].filter(Boolean);\n      var attrs = {\n        name: props.name,\n        onBlur: baseOnBlur,\n        onInput: baseOnInput,\n        onChange: baseOnChange\n      };\n\n      attrs['onUpdate:modelValue'] = function (e) {\n        return onChangeHandler(e, validateOnModelUpdate);\n      };\n\n      if (hasCheckedAttr(ctx.attrs.type) && checked) {\n        attrs.checked = checked.value;\n      }\n\n      var tag = resolveTag(props, ctx);\n\n      if (shouldHaveValueBinding(tag, ctx.attrs)) {\n        attrs.value = value.value;\n      }\n\n      return attrs;\n    });\n\n    function slotProps() {\n      return {\n        field: fieldProps.value,\n        value: value.value,\n        meta: meta,\n        errors: errors.value,\n        errorMessage: errorMessage.value,\n        validate: validateField,\n        resetField: resetField,\n        handleChange: onChangeHandler,\n        handleInput: onInputHandler,\n        handleReset: handleReset,\n        handleBlur: handleBlur,\n        setTouched: setTouched,\n        setErrors: setErrors\n      };\n    }\n\n    ctx.expose({\n      setErrors: setErrors,\n      setTouched: setTouched,\n      reset: resetField,\n      validate: validateField,\n      handleChange: handleChange\n    });\n    return function () {\n      var tag = resolveDynamicComponent(resolveTag(props, ctx));\n      var children = normalizeChildren(tag, ctx, slotProps);\n\n      if (tag) {\n        return h(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);\n      }\n\n      return children;\n    };\n  }\n});\n\nfunction resolveTag(props, ctx) {\n  var tag = props.as || '';\n\n  if (!props.as && !ctx.slots[\"default\"]) {\n    tag = 'input';\n  }\n\n  return tag;\n}\n\nfunction resolveValidationTriggers(props) {\n  var _a, _b, _c, _d;\n\n  var _getConfig = getConfig(),\n      validateOnInput = _getConfig.validateOnInput,\n      validateOnChange = _getConfig.validateOnChange,\n      validateOnBlur = _getConfig.validateOnBlur,\n      validateOnModelUpdate = _getConfig.validateOnModelUpdate;\n\n  return {\n    validateOnInput: (_a = props.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,\n    validateOnChange: (_b = props.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,\n    validateOnBlur: (_c = props.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,\n    validateOnModelUpdate: (_d = props.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate\n  };\n}\n\nfunction resolveInitialValue(props, ctx) {\n  // Gets the initial value either from `value` prop/attr or `v-model` binding (modelValue)\n  // For checkboxes and radio buttons it will always be the model value not the `value` attribute\n  if (!hasCheckedAttr(ctx.attrs.type)) {\n    return isPropPresent(props, 'modelValue') ? props.modelValue : ctx.attrs.value;\n  }\n\n  return isPropPresent(props, 'modelValue') ? props.modelValue : undefined;\n}\n\nvar Field = FieldImpl;\nvar FORM_COUNTER = 0;\n\nfunction useForm(opts) {\n  var _a;\n\n  var formId = FORM_COUNTER++; // Prevents fields from double resetting their values, which causes checkboxes to toggle their initial value\n  // TODO: This won't be needed if we centralize all the state inside the `form` for form inputs\n\n  var RESET_LOCK = false; // A lookup containing fields or field groups\n\n  var fieldsByPath = ref({}); // If the form is currently submitting\n\n  var isSubmitting = ref(false); // The number of times the user tried to submit the form\n\n  var submitCount = ref(0); // field arrays managed by this form\n\n  var fieldArrays = []; // a private ref for all form values\n\n  var formValues = reactive(klona(unref(opts === null || opts === void 0 ? void 0 : opts.initialValues) || {})); // the source of errors for the form fields\n\n  var _useErrorBag = useErrorBag(opts === null || opts === void 0 ? void 0 : opts.initialErrors),\n      errorBag = _useErrorBag.errorBag,\n      setErrorBag = _useErrorBag.setErrorBag,\n      setFieldErrorBag = _useErrorBag.setFieldErrorBag; // Gets the first error of each field\n\n\n  var errors = computed(function () {\n    return keysOf(errorBag.value).reduce(function (acc, key) {\n      var bag = errorBag.value[key];\n\n      if (bag && bag.length) {\n        acc[key] = bag[0];\n      }\n\n      return acc;\n    }, {});\n  });\n\n  function getFirstFieldAtPath(path) {\n    var fieldOrGroup = fieldsByPath.value[path];\n    return Array.isArray(fieldOrGroup) ? fieldOrGroup[0] : fieldOrGroup;\n  }\n\n  function fieldExists(path) {\n    return !!fieldsByPath.value[path];\n  }\n  /**\r\n   * Holds a computed reference to all fields names and labels\r\n   */\n\n\n  var fieldNames = computed(function () {\n    return keysOf(fieldsByPath.value).reduce(function (names, path) {\n      var field = getFirstFieldAtPath(path);\n\n      if (field) {\n        names[path] = unref(field.label || field.name) || '';\n      }\n\n      return names;\n    }, {});\n  });\n  var fieldBailsMap = computed(function () {\n    return keysOf(fieldsByPath.value).reduce(function (map, path) {\n      var _a;\n\n      var field = getFirstFieldAtPath(path);\n\n      if (field) {\n        map[path] = (_a = field.bails) !== null && _a !== void 0 ? _a : true;\n      }\n\n      return map;\n    }, {});\n  }); // mutable non-reactive reference to initial errors\n  // we need this to process initial errors then unset them\n\n  var initialErrors = Object.assign({}, (opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {});\n  var keepValuesOnUnmount = (_a = opts === null || opts === void 0 ? void 0 : opts.keepValuesOnUnmount) !== null && _a !== void 0 ? _a : false; // initial form values\n\n  var _useFormInitialValues = useFormInitialValues(fieldsByPath, formValues, opts === null || opts === void 0 ? void 0 : opts.initialValues),\n      initialValues = _useFormInitialValues.initialValues,\n      originalInitialValues = _useFormInitialValues.originalInitialValues,\n      setInitialValues = _useFormInitialValues.setInitialValues; // form meta aggregations\n\n\n  var meta = useFormMeta(fieldsByPath, formValues, originalInitialValues, errors);\n  var schema = opts === null || opts === void 0 ? void 0 : opts.validationSchema;\n  var formCtx = {\n    formId: formId,\n    fieldsByPath: fieldsByPath,\n    values: formValues,\n    errorBag: errorBag,\n    errors: errors,\n    schema: schema,\n    submitCount: submitCount,\n    meta: meta,\n    isSubmitting: isSubmitting,\n    fieldArrays: fieldArrays,\n    keepValuesOnUnmount: keepValuesOnUnmount,\n    validateSchema: unref(schema) ? validateSchema : undefined,\n    validate: validate,\n    register: registerField,\n    unregister: unregisterField,\n    setFieldErrorBag: setFieldErrorBag,\n    validateField: validateField,\n    setFieldValue: setFieldValue,\n    setValues: setValues,\n    setErrors: setErrors,\n    setFieldError: setFieldError,\n    setFieldTouched: setFieldTouched,\n    setTouched: setTouched,\n    resetForm: resetForm,\n    handleSubmit: handleSubmit,\n    stageInitialValue: stageInitialValue,\n    unsetInitialValue: unsetInitialValue,\n    setFieldInitialValue: setFieldInitialValue,\n    useFieldModel: useFieldModel\n  };\n\n  function isFieldGroup(fieldOrGroup) {\n    return Array.isArray(fieldOrGroup);\n  }\n\n  function applyFieldMutation(fieldOrGroup, mutation) {\n    if (Array.isArray(fieldOrGroup)) {\n      return fieldOrGroup.forEach(mutation);\n    }\n\n    return mutation(fieldOrGroup);\n  }\n\n  function mutateAllFields(mutation) {\n    Object.values(fieldsByPath.value).forEach(function (field) {\n      if (!field) {\n        return;\n      } // avoid resetting the field values, because they should've been reset already.\n\n\n      applyFieldMutation(field, mutation);\n    });\n  }\n  /**\r\n   * Manually sets an error message on a specific field\r\n   */\n\n\n  function setFieldError(field, message) {\n    setFieldErrorBag(field, message);\n  }\n  /**\r\n   * Sets errors for the fields specified in the object\r\n   */\n\n\n  function setErrors(fields) {\n    setErrorBag(fields);\n  }\n  /**\r\n   * Sets a single field value\r\n   */\n\n\n  function setFieldValue(field, value) {\n    var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      force: false\n    },\n        force = _ref4.force;\n\n    var _a;\n\n    var fieldInstance = fieldsByPath.value[field];\n    var clonedValue = klona(value); // field wasn't found, create a virtual field as a placeholder\n\n    if (!fieldInstance) {\n      setInPath(formValues, field, clonedValue);\n      return;\n    }\n\n    if (isFieldGroup(fieldInstance) && ((_a = fieldInstance[0]) === null || _a === void 0 ? void 0 : _a.type) === 'checkbox' && !Array.isArray(value)) {\n      // Multiple checkboxes, and only one of them got updated\n      var _newValue = klona(resolveNextCheckboxValue(getFromPath(formValues, field) || [], value, undefined));\n\n      setInPath(formValues, field, _newValue);\n      return;\n    }\n\n    var newValue = value; // Single Checkbox: toggles the field value unless the field is being reset then force it\n\n    if (!isFieldGroup(fieldInstance) && fieldInstance.type === 'checkbox' && !force && !RESET_LOCK) {\n      newValue = klona(resolveNextCheckboxValue(getFromPath(formValues, field), value, unref(fieldInstance.uncheckedValue)));\n    }\n\n    setInPath(formValues, field, newValue);\n  }\n  /**\r\n   * Sets multiple fields values\r\n   */\n\n\n  function setValues(fields) {\n    // clean up old values\n    keysOf(formValues).forEach(function (key) {\n      delete formValues[key];\n    }); // set up new values\n\n    keysOf(fields).forEach(function (path) {\n      setFieldValue(path, fields[path]);\n    }); // regenerate the arrays when the form values change\n\n    fieldArrays.forEach(function (f) {\n      return f && f.reset();\n    });\n  }\n\n  function createModel(path) {\n    var _useFieldValue3 = _useFieldValue(path),\n        value = _useFieldValue3.value;\n\n    watch(value, function () {\n      if (!fieldExists(unref(path))) {\n        validate({\n          mode: 'validated-only'\n        });\n      }\n    }, {\n      deep: true\n    });\n    return value;\n  }\n\n  function useFieldModel(path) {\n    if (!Array.isArray(path)) {\n      return createModel(path);\n    }\n\n    return path.map(createModel);\n  }\n  /**\r\n   * Sets the touched meta state on a field\r\n   */\n\n\n  function setFieldTouched(field, isTouched) {\n    var fieldInstance = fieldsByPath.value[field];\n\n    if (fieldInstance) {\n      applyFieldMutation(fieldInstance, function (f) {\n        return f.setTouched(isTouched);\n      });\n    }\n  }\n  /**\r\n   * Sets the touched meta state on multiple fields\r\n   */\n\n\n  function setTouched(fields) {\n    keysOf(fields).forEach(function (field) {\n      setFieldTouched(field, !!fields[field]);\n    });\n  }\n  /**\r\n   * Resets all fields\r\n   */\n\n\n  function resetForm(state) {\n    RESET_LOCK = true; // set initial values if provided\n\n    if (state === null || state === void 0 ? void 0 : state.values) {\n      setInitialValues(state.values);\n      setValues(state === null || state === void 0 ? void 0 : state.values);\n    } else {\n      // clean up the initial values back to the original\n      setInitialValues(originalInitialValues.value); // otherwise clean the current values\n\n      setValues(originalInitialValues.value);\n    } // avoid resetting the field values, because they should've been reset already.\n\n\n    mutateAllFields(function (f) {\n      return f.resetField();\n    });\n\n    if (state === null || state === void 0 ? void 0 : state.touched) {\n      setTouched(state.touched);\n    }\n\n    setErrors((state === null || state === void 0 ? void 0 : state.errors) || {});\n    submitCount.value = (state === null || state === void 0 ? void 0 : state.submitCount) || 0;\n    nextTick(function () {\n      RESET_LOCK = false;\n    });\n  }\n\n  function insertFieldAtPath(field, path) {\n    var rawField = markRaw(field);\n    var fieldPath = path; // first field at that path\n\n    if (!fieldsByPath.value[fieldPath]) {\n      fieldsByPath.value[fieldPath] = rawField;\n      return;\n    }\n\n    var fieldAtPath = fieldsByPath.value[fieldPath];\n\n    if (fieldAtPath && !Array.isArray(fieldAtPath)) {\n      fieldsByPath.value[fieldPath] = [fieldAtPath];\n    } // add the new array to that path\n\n\n    fieldsByPath.value[fieldPath] = [].concat(_toConsumableArray(fieldsByPath.value[fieldPath]), [rawField]);\n  }\n\n  function removeFieldFromPath(field, path) {\n    var fieldPath = path;\n    var fieldAtPath = fieldsByPath.value[fieldPath];\n\n    if (!fieldAtPath) {\n      return;\n    } // same field at path\n\n\n    if (!isFieldGroup(fieldAtPath) && field.id === fieldAtPath.id) {\n      delete fieldsByPath.value[fieldPath];\n      return;\n    }\n\n    if (isFieldGroup(fieldAtPath)) {\n      var idx = fieldAtPath.findIndex(function (f) {\n        return f.id === field.id;\n      });\n\n      if (idx === -1) {\n        return;\n      }\n\n      fieldAtPath.splice(idx, 1);\n\n      if (!fieldAtPath.length) {\n        delete fieldsByPath.value[fieldPath];\n      }\n    }\n  }\n\n  function registerField(field) {\n    var fieldPath = unref(field.name);\n    insertFieldAtPath(field, fieldPath);\n\n    if (isRef(field.name)) {\n      // ensures when a field's name was already taken that it preserves its same value\n      // necessary for fields generated by loops\n      watch(field.name, /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(newPath, oldPath) {\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.next = 2;\n                  return nextTick();\n\n                case 2:\n                  removeFieldFromPath(field, oldPath);\n                  insertFieldAtPath(field, newPath); // re-validate if either path had errors before\n\n                  if (errors.value[oldPath] || errors.value[newPath]) {\n                    // clear up both paths errors\n                    setFieldError(oldPath, undefined);\n                    validateField(newPath);\n                  } // clean up the old path if no other field is sharing that name\n                  // #3325\n\n\n                  _context6.next = 7;\n                  return nextTick();\n\n                case 7:\n                  if (!fieldExists(oldPath)) {\n                    unsetPath(formValues, oldPath);\n                  }\n\n                case 8:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6);\n        }));\n\n        return function (_x17, _x18) {\n          return _ref5.apply(this, arguments);\n        };\n      }());\n    } // if field already had errors (initial errors) that's not user-set, validate it again to ensure state is correct\n    // the difference being that `initialErrors` will contain the error message while other errors (pre-validated schema) won't have them as initial errors\n    // #3342\n\n\n    var initialErrorMessage = unref(field.errorMessage);\n\n    if (initialErrorMessage && (initialErrors === null || initialErrors === void 0 ? void 0 : initialErrors[fieldPath]) !== initialErrorMessage) {\n      validateField(fieldPath);\n    } // marks the initial error as \"consumed\" so it won't be matched later with same non-initial error\n\n\n    delete initialErrors[fieldPath];\n  }\n\n  function unregisterField(field) {\n    var fieldName = unref(field.name);\n    var fieldInstance = fieldsByPath.value[fieldName];\n    var isGroup = !!fieldInstance && isFieldGroup(fieldInstance);\n    removeFieldFromPath(field, fieldName); // clears a field error on unmounted\n    // we wait till next tick to make sure if the field is completely removed and doesn't have any siblings like checkboxes\n\n    nextTick(function () {\n      var _a;\n\n      var shouldKeepValue = (_a = unref(field.keepValueOnUnmount)) !== null && _a !== void 0 ? _a : unref(keepValuesOnUnmount);\n      var currentGroupValue = getFromPath(formValues, fieldName); // The boolean here is we check if the field still belongs to the same control group with that name\n      // if another group claimed the name, we should avoid handling it since it is no longer the same group\n      // this happens with `v-for` over some checkboxes and field arrays.\n      // also if the group no longer exist we can assume this group was the last one that controlled it\n\n      var isSameGroup = isGroup && (fieldInstance === fieldsByPath.value[fieldName] || !fieldsByPath.value[fieldName]); // group field that still has a dangling value, the field may exist or not after it was removed.\n      // This used to be handled in the useField composable but the form has better context on when it should/not happen.\n      // if it does belong to it that means the group still exists\n      // #3844\n\n      if (isSameGroup && Array.isArray(currentGroupValue) && !shouldKeepValue) {\n        var valueIdx = currentGroupValue.findIndex(function (i) {\n          return es6(i, unref(field.checkedValue));\n        });\n\n        if (valueIdx > -1) {\n          var newVal = _toConsumableArray(currentGroupValue);\n\n          newVal.splice(valueIdx, 1);\n          setFieldValue(fieldName, newVal, {\n            force: true\n          });\n        }\n      } // Field was removed entirely, we should unset its path\n      // #3384\n\n\n      if (!fieldExists(fieldName)) {\n        setFieldError(fieldName, undefined); // Checks if the field was configured to be unset during unmount or not\n        // Checks both the form-level config and field-level one\n        // Field has the priority if it is set, otherwise it goes to the form settings\n\n        if (shouldKeepValue) {\n          return;\n        }\n\n        if (isGroup && !isEmptyContainer(getFromPath(formValues, fieldName))) {\n          return;\n        }\n\n        unsetPath(formValues, fieldName);\n      }\n    });\n  }\n\n  function validate(_x19) {\n    return _validate4.apply(this, arguments);\n  }\n\n  function _validate4() {\n    _validate4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(opts) {\n      var validations, results, errors, _iterator4, _step4, validation;\n\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              mutateAllFields(function (f) {\n                return f.meta.validated = true;\n              });\n\n              if (!formCtx.validateSchema) {\n                _context7.next = 3;\n                break;\n              }\n\n              return _context7.abrupt(\"return\", formCtx.validateSchema((opts === null || opts === void 0 ? void 0 : opts.mode) || 'force'));\n\n            case 3:\n              _context7.next = 5;\n              return Promise.all(Object.values(fieldsByPath.value).map(function (field) {\n                var fieldInstance = Array.isArray(field) ? field[0] : field;\n\n                if (!fieldInstance) {\n                  return Promise.resolve({\n                    key: '',\n                    valid: true,\n                    errors: []\n                  });\n                }\n\n                return fieldInstance.validate(opts).then(function (result) {\n                  return {\n                    key: unref(fieldInstance.name),\n                    valid: result.valid,\n                    errors: result.errors\n                  };\n                });\n              }));\n\n            case 5:\n              validations = _context7.sent;\n              results = {};\n              errors = {};\n              _iterator4 = _createForOfIteratorHelper(validations);\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  validation = _step4.value;\n                  results[validation.key] = {\n                    valid: validation.valid,\n                    errors: validation.errors\n                  };\n\n                  if (validation.errors.length) {\n                    errors[validation.key] = validation.errors[0];\n                  }\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n\n              return _context7.abrupt(\"return\", {\n                valid: validations.every(function (r) {\n                  return r.valid;\n                }),\n                results: results,\n                errors: errors\n              });\n\n            case 11:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n    return _validate4.apply(this, arguments);\n  }\n\n  function validateField(_x20) {\n    return _validateField.apply(this, arguments);\n  }\n\n  function _validateField() {\n    _validateField = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(field) {\n      var fieldInstance;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              fieldInstance = fieldsByPath.value[field];\n\n              if (fieldInstance) {\n                _context8.next = 4;\n                break;\n              }\n\n              warn$1(\"field with name \".concat(field, \" was not found\"));\n              return _context8.abrupt(\"return\", Promise.resolve({\n                errors: [],\n                valid: true\n              }));\n\n            case 4:\n              if (!Array.isArray(fieldInstance)) {\n                _context8.next = 6;\n                break;\n              }\n\n              return _context8.abrupt(\"return\", fieldInstance.map(function (f) {\n                return f.validate();\n              })[0]);\n\n            case 6:\n              return _context8.abrupt(\"return\", fieldInstance.validate());\n\n            case 7:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n    return _validateField.apply(this, arguments);\n  }\n\n  function handleSubmit(fn, onValidationError) {\n    return function submissionHandler(e) {\n      if (e instanceof Event) {\n        e.preventDefault();\n        e.stopPropagation();\n      } // Touch all fields\n\n\n      setTouched(keysOf(fieldsByPath.value).reduce(function (acc, field) {\n        acc[field] = true;\n        return acc;\n      }, {}));\n      isSubmitting.value = true;\n      submitCount.value++;\n      return validate().then(function (result) {\n        if (result.valid && typeof fn === 'function') {\n          return fn(klona(formValues), {\n            evt: e,\n            setErrors: setErrors,\n            setFieldError: setFieldError,\n            setTouched: setTouched,\n            setFieldTouched: setFieldTouched,\n            setValues: setValues,\n            setFieldValue: setFieldValue,\n            resetForm: resetForm\n          });\n        }\n\n        if (!result.valid && typeof onValidationError === 'function') {\n          onValidationError({\n            values: klona(formValues),\n            evt: e,\n            errors: result.errors,\n            results: result.results\n          });\n        }\n      }).then(function (returnVal) {\n        isSubmitting.value = false;\n        return returnVal;\n      }, function (err) {\n        isSubmitting.value = false; // re-throw the err so it doesn't go silent\n\n        throw err;\n      });\n    };\n  }\n\n  function setFieldInitialValue(path, value) {\n    setInPath(initialValues.value, path, klona(value));\n  }\n\n  function unsetInitialValue(path) {\n    unsetPath(initialValues.value, path);\n  }\n  /**\r\n   * Sneaky function to set initial field values\r\n   */\n\n\n  function stageInitialValue(path, value) {\n    var updateOriginal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    setInPath(formValues, path, value);\n    setFieldInitialValue(path, value);\n\n    if (updateOriginal && !(opts === null || opts === void 0 ? void 0 : opts.initialValues)) {\n      setInPath(originalInitialValues.value, path, klona(value));\n    }\n  }\n\n  function _validateSchema() {\n    return _validateSchema2.apply(this, arguments);\n  }\n  /**\r\n   * Batches validation runs in 5ms batches\r\n   * Must have two distinct batch queues to make sure they don't override each other settings #3783\r\n   */\n\n\n  function _validateSchema2() {\n    _validateSchema2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n      var schemaValue, formResult;\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              schemaValue = unref(schema);\n\n              if (schemaValue) {\n                _context9.next = 3;\n                break;\n              }\n\n              return _context9.abrupt(\"return\", {\n                valid: true,\n                results: {},\n                errors: {}\n              });\n\n            case 3:\n              if (!isYupValidator(schemaValue)) {\n                _context9.next = 9;\n                break;\n              }\n\n              _context9.next = 6;\n              return validateYupSchema(schemaValue, formValues);\n\n            case 6:\n              _context9.t0 = _context9.sent;\n              _context9.next = 12;\n              break;\n\n            case 9:\n              _context9.next = 11;\n              return validateObjectSchema(schemaValue, formValues, {\n                names: fieldNames.value,\n                bailsMap: fieldBailsMap.value\n              });\n\n            case 11:\n              _context9.t0 = _context9.sent;\n\n            case 12:\n              formResult = _context9.t0;\n              return _context9.abrupt(\"return\", formResult);\n\n            case 14:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }));\n    return _validateSchema2.apply(this, arguments);\n  }\n\n  var debouncedSilentValidation = debounceAsync(_validateSchema, 5);\n  var debouncedValidation = debounceAsync(_validateSchema, 5);\n\n  function validateSchema(_x21) {\n    return _validateSchema3.apply(this, arguments);\n  }\n\n  function _validateSchema3() {\n    _validateSchema3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(mode) {\n      var formResult, fieldsById, currentErrorsPaths, paths;\n      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return mode === 'silent' ? debouncedSilentValidation() : debouncedValidation();\n\n            case 2:\n              formResult = _context10.sent;\n              // fields by id lookup\n              fieldsById = formCtx.fieldsByPath.value || {}; // errors fields names, we need it to also check if custom errors are updated\n\n              currentErrorsPaths = keysOf(formCtx.errorBag.value); // collect all the keys from the schema and all fields\n              // this ensures we have a complete keymap of all the fields\n\n              paths = _toConsumableArray(new Set([].concat(_toConsumableArray(keysOf(formResult.results)), _toConsumableArray(keysOf(fieldsById)), _toConsumableArray(currentErrorsPaths)))); // aggregates the paths into a single result object while applying the results on the fields\n\n              return _context10.abrupt(\"return\", paths.reduce(function (validation, path) {\n                var field = fieldsById[path];\n                var messages = (formResult.results[path] || {\n                  errors: []\n                }).errors;\n                var fieldResult = {\n                  errors: messages,\n                  valid: !messages.length\n                };\n                validation.results[path] = fieldResult;\n\n                if (!fieldResult.valid) {\n                  validation.errors[path] = fieldResult.errors[0];\n                } // field not rendered\n\n\n                if (!field) {\n                  setFieldError(path, messages);\n                  return validation;\n                } // always update the valid flag regardless of the mode\n\n\n                applyFieldMutation(field, function (f) {\n                  return f.meta.valid = fieldResult.valid;\n                });\n\n                if (mode === 'silent') {\n                  return validation;\n                }\n\n                var wasValidated = Array.isArray(field) ? field.some(function (f) {\n                  return f.meta.validated;\n                }) : field.meta.validated;\n\n                if (mode === 'validated-only' && !wasValidated) {\n                  return validation;\n                }\n\n                applyFieldMutation(field, function (f) {\n                  return f.setState({\n                    errors: fieldResult.errors\n                  });\n                });\n                return validation;\n              }, {\n                valid: formResult.valid,\n                results: {},\n                errors: {}\n              }));\n\n            case 7:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10);\n    }));\n    return _validateSchema3.apply(this, arguments);\n  }\n\n  var submitForm = handleSubmit(function (_, _ref6) {\n    var evt = _ref6.evt;\n\n    if (isFormSubmitEvent(evt)) {\n      evt.target.submit();\n    }\n  }); // Trigger initial validation\n\n  onMounted(function () {\n    if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {\n      setErrors(opts.initialErrors);\n    }\n\n    if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {\n      setTouched(opts.initialTouched);\n    } // if validate on mount was enabled\n\n\n    if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {\n      validate();\n      return;\n    } // otherwise run initial silent validation through schema if available\n    // the useField should skip their own silent validation if a yup schema is present\n\n\n    if (formCtx.validateSchema) {\n      formCtx.validateSchema('silent');\n    }\n  });\n\n  if (isRef(schema)) {\n    watch(schema, function () {\n      var _a;\n\n      (_a = formCtx.validateSchema) === null || _a === void 0 ? void 0 : _a.call(formCtx, 'validated-only');\n    });\n  } // Provide injections\n\n\n  provide(FormContextKey, formCtx);\n\n  if (process.env.NODE_ENV !== 'production') {\n    registerFormWithDevTools(formCtx);\n    watch(function () {\n      return Object.assign(Object.assign({\n        errors: errorBag.value\n      }, meta.value), {\n        values: formValues,\n        isSubmitting: isSubmitting.value,\n        submitCount: submitCount.value\n      });\n    }, refreshInspector, {\n      deep: true\n    });\n  }\n\n  return {\n    errors: errors,\n    meta: meta,\n    values: formValues,\n    isSubmitting: isSubmitting,\n    submitCount: submitCount,\n    validate: validate,\n    validateField: validateField,\n    handleReset: function handleReset() {\n      return resetForm();\n    },\n    resetForm: resetForm,\n    handleSubmit: handleSubmit,\n    submitForm: submitForm,\n    setFieldError: setFieldError,\n    setErrors: setErrors,\n    setFieldValue: setFieldValue,\n    setValues: setValues,\n    setFieldTouched: setFieldTouched,\n    setTouched: setTouched,\n    useFieldModel: useFieldModel\n  };\n}\n/**\r\n * Manages form meta aggregation\r\n */\n\n\nfunction useFormMeta(fieldsByPath, currentValues, initialValues, errors) {\n  var MERGE_STRATEGIES = {\n    touched: 'some',\n    pending: 'some',\n    valid: 'every'\n  };\n  var isDirty = computed(function () {\n    return !es6(currentValues, unref(initialValues));\n  });\n\n  function calculateFlags() {\n    var fields = Object.values(fieldsByPath.value).flat(1).filter(Boolean);\n    return keysOf(MERGE_STRATEGIES).reduce(function (acc, flag) {\n      var mergeMethod = MERGE_STRATEGIES[flag];\n      acc[flag] = fields[mergeMethod](function (field) {\n        return field.meta[flag];\n      });\n      return acc;\n    }, {});\n  }\n\n  var flags = reactive(calculateFlags());\n  watchEffect(function () {\n    var value = calculateFlags();\n    flags.touched = value.touched;\n    flags.valid = value.valid;\n    flags.pending = value.pending;\n  });\n  return computed(function () {\n    return Object.assign(Object.assign({\n      initialValues: unref(initialValues)\n    }, flags), {\n      valid: flags.valid && !keysOf(errors.value).length,\n      dirty: isDirty.value\n    });\n  });\n}\n/**\r\n * Manages the initial values prop\r\n */\n\n\nfunction useFormInitialValues(fields, formValues, providedValues) {\n  // these are the mutable initial values as the fields are mounted/unmounted\n  var initialValues = ref(klona(unref(providedValues)) || {}); // these are the original initial value as provided by the user initially, they don't keep track of conditional fields\n  // this is important because some conditional fields will overwrite the initial values for other fields who had the same name\n  // like array fields, any push/insert operation will overwrite the initial values because they \"create new fields\"\n  // so these are the values that the reset function should use\n  // these only change when the user explicitly chanegs the initial values or when the user resets them with new values.\n\n  var originalInitialValues = ref(klona(unref(providedValues)) || {});\n\n  function setInitialValues(values) {\n    var updateFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    initialValues.value = klona(values);\n    originalInitialValues.value = klona(values);\n\n    if (!updateFields) {\n      return;\n    } // update the pristine non-touched fields\n    // those are excluded because it's unlikely you want to change the form values using initial values\n    // we mostly watch them for API population or newly inserted fields\n    // if the user API is taking too much time before user interaction they should consider disabling or hiding their inputs until the values are ready\n\n\n    keysOf(fields.value).forEach(function (fieldPath) {\n      var field = fields.value[fieldPath];\n      var wasTouched = Array.isArray(field) ? field.some(function (f) {\n        return f.meta.touched;\n      }) : field === null || field === void 0 ? void 0 : field.meta.touched;\n\n      if (!field || wasTouched) {\n        return;\n      }\n\n      var newValue = getFromPath(initialValues.value, fieldPath);\n      setInPath(formValues, fieldPath, klona(newValue));\n    });\n  }\n\n  if (isRef(providedValues)) {\n    watch(providedValues, function (value) {\n      setInitialValues(value, true);\n    }, {\n      deep: true\n    });\n  }\n\n  return {\n    initialValues: initialValues,\n    originalInitialValues: originalInitialValues,\n    setInitialValues: setInitialValues\n  };\n}\n\nfunction useErrorBag(initialErrors) {\n  var errorBag = ref({});\n\n  function normalizeErrorItem(message) {\n    return Array.isArray(message) ? message : message ? [message] : [];\n  }\n  /**\r\n   * Manually sets an error message on a specific field\r\n   */\n\n\n  function setFieldErrorBag(field, message) {\n    if (!message) {\n      delete errorBag.value[field];\n      return;\n    }\n\n    errorBag.value[field] = normalizeErrorItem(message);\n  }\n  /**\r\n   * Sets errors for the fields specified in the object\r\n   */\n\n\n  function setErrorBag(fields) {\n    errorBag.value = keysOf(fields).reduce(function (acc, key) {\n      var message = fields[key];\n\n      if (message) {\n        acc[key] = normalizeErrorItem(message);\n      }\n\n      return acc;\n    }, {});\n  }\n\n  if (initialErrors) {\n    setErrorBag(initialErrors);\n  }\n\n  return {\n    errorBag: errorBag,\n    setErrorBag: setErrorBag,\n    setFieldErrorBag: setFieldErrorBag\n  };\n}\n\nvar FormImpl = defineComponent({\n  name: 'Form',\n  inheritAttrs: false,\n  props: {\n    as: {\n      type: String,\n      \"default\": 'form'\n    },\n    validationSchema: {\n      type: Object,\n      \"default\": undefined\n    },\n    initialValues: {\n      type: Object,\n      \"default\": undefined\n    },\n    initialErrors: {\n      type: Object,\n      \"default\": undefined\n    },\n    initialTouched: {\n      type: Object,\n      \"default\": undefined\n    },\n    validateOnMount: {\n      type: Boolean,\n      \"default\": false\n    },\n    onSubmit: {\n      type: Function,\n      \"default\": undefined\n    },\n    onInvalidSubmit: {\n      type: Function,\n      \"default\": undefined\n    },\n    keepValues: {\n      type: Boolean,\n      \"default\": false\n    }\n  },\n  setup: function setup(props, ctx) {\n    var initialValues = toRef(props, 'initialValues');\n    var validationSchema = toRef(props, 'validationSchema');\n    var keepValues = toRef(props, 'keepValues');\n\n    var _useForm = useForm({\n      validationSchema: validationSchema.value ? validationSchema : undefined,\n      initialValues: initialValues,\n      initialErrors: props.initialErrors,\n      initialTouched: props.initialTouched,\n      validateOnMount: props.validateOnMount,\n      keepValuesOnUnmount: keepValues\n    }),\n        errors = _useForm.errors,\n        values = _useForm.values,\n        meta = _useForm.meta,\n        isSubmitting = _useForm.isSubmitting,\n        submitCount = _useForm.submitCount,\n        validate = _useForm.validate,\n        validateField = _useForm.validateField,\n        handleReset = _useForm.handleReset,\n        resetForm = _useForm.resetForm,\n        handleSubmit = _useForm.handleSubmit,\n        setErrors = _useForm.setErrors,\n        setFieldError = _useForm.setFieldError,\n        setFieldValue = _useForm.setFieldValue,\n        setValues = _useForm.setValues,\n        setFieldTouched = _useForm.setFieldTouched,\n        setTouched = _useForm.setTouched;\n\n    var submitForm = handleSubmit(function (_, _ref7) {\n      var evt = _ref7.evt;\n\n      if (isFormSubmitEvent(evt)) {\n        evt.target.submit();\n      }\n    }, props.onInvalidSubmit);\n    var onSubmit = props.onSubmit ? handleSubmit(props.onSubmit, props.onInvalidSubmit) : submitForm;\n\n    function handleFormReset(e) {\n      if (isEvent(e)) {\n        // Prevent default form reset behavior\n        e.preventDefault();\n      }\n\n      handleReset();\n\n      if (typeof ctx.attrs.onReset === 'function') {\n        ctx.attrs.onReset();\n      }\n    }\n\n    function handleScopedSlotSubmit(evt, onSubmit) {\n      var onSuccess = typeof evt === 'function' && !onSubmit ? evt : onSubmit;\n      return handleSubmit(onSuccess, props.onInvalidSubmit)(evt);\n    }\n\n    function slotProps() {\n      return {\n        meta: meta.value,\n        errors: errors.value,\n        values: values,\n        isSubmitting: isSubmitting.value,\n        submitCount: submitCount.value,\n        validate: validate,\n        validateField: validateField,\n        handleSubmit: handleScopedSlotSubmit,\n        handleReset: handleReset,\n        submitForm: submitForm,\n        setErrors: setErrors,\n        setFieldError: setFieldError,\n        setFieldValue: setFieldValue,\n        setValues: setValues,\n        setFieldTouched: setFieldTouched,\n        setTouched: setTouched,\n        resetForm: resetForm\n      };\n    } // expose these functions and methods as part of public API\n\n\n    ctx.expose({\n      setFieldError: setFieldError,\n      setErrors: setErrors,\n      setFieldValue: setFieldValue,\n      setValues: setValues,\n      setFieldTouched: setFieldTouched,\n      setTouched: setTouched,\n      resetForm: resetForm,\n      validate: validate,\n      validateField: validateField\n    });\n    return function renderForm() {\n      // avoid resolving the form component as itself\n      var tag = props.as === 'form' ? props.as : resolveDynamicComponent(props.as);\n      var children = normalizeChildren(tag, ctx, slotProps);\n\n      if (!props.as) {\n        return children;\n      } // Attributes to add on a native `form` tag\n\n\n      var formAttrs = props.as === 'form' ? {\n        // Disables native validation as vee-validate will handle it.\n        novalidate: true\n      } : {};\n      return h(tag, Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), {\n        onSubmit: onSubmit,\n        onReset: handleFormReset\n      }), children);\n    };\n  }\n});\nvar Form = FormImpl;\n\nfunction useFieldArray(arrayPath) {\n  var form = injectWithSelf(FormContextKey, undefined);\n  var fields = ref([]); // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n  var noOp = function noOp() {};\n\n  var noOpApi = {\n    fields: fields,\n    remove: noOp,\n    push: noOp,\n    swap: noOp,\n    insert: noOp,\n    update: noOp,\n    replace: noOp,\n    prepend: noOp,\n    move: noOp\n  };\n\n  if (!form) {\n    warn('FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly');\n    return noOpApi;\n  }\n\n  if (!unref(arrayPath)) {\n    warn('FieldArray requires a field path to be provided, did you forget to pass the `name` prop?');\n    return noOpApi;\n  }\n\n  var alreadyExists = form.fieldArrays.find(function (a) {\n    return unref(a.path) === unref(arrayPath);\n  });\n\n  if (alreadyExists) {\n    return alreadyExists;\n  }\n\n  var entryCounter = 0;\n\n  function initFields() {\n    var currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []) || [];\n    fields.value = currentValues.map(createEntry);\n    updateEntryFlags();\n  }\n\n  initFields();\n\n  function updateEntryFlags() {\n    var fieldsLength = fields.value.length;\n\n    for (var i = 0; i < fieldsLength; i++) {\n      var entry = fields.value[i];\n      entry.isFirst = i === 0;\n      entry.isLast = i === fieldsLength - 1;\n    }\n  }\n\n  function createEntry(value) {\n    var key = entryCounter++;\n    var entry = {\n      key: key,\n      value: computed({\n        get: function get() {\n          var currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []) || [];\n          var idx = fields.value.findIndex(function (e) {\n            return e.key === key;\n          });\n          return idx === -1 ? value : currentValues[idx];\n        },\n        set: function set(value) {\n          var idx = fields.value.findIndex(function (e) {\n            return e.key === key;\n          });\n\n          if (idx === -1) {\n            warn(\"Attempting to update a non-existent array item\");\n            return;\n          }\n\n          update(idx, value);\n        }\n      }),\n      isFirst: false,\n      isLast: false\n    };\n    return entry;\n  }\n\n  function remove(idx) {\n    var pathName = unref(arrayPath);\n    var pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n\n    if (!pathValue || !Array.isArray(pathValue)) {\n      return;\n    }\n\n    var newValue = _toConsumableArray(pathValue);\n\n    newValue.splice(idx, 1);\n    form === null || form === void 0 ? void 0 : form.unsetInitialValue(pathName + \"[\".concat(idx, \"]\"));\n    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);\n    fields.value.splice(idx, 1);\n    updateEntryFlags();\n  }\n\n  function push(value) {\n    var pathName = unref(arrayPath);\n    var pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n    var normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;\n\n    if (!Array.isArray(normalizedPathValue)) {\n      return;\n    }\n\n    var newValue = _toConsumableArray(normalizedPathValue);\n\n    newValue.push(value);\n    form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + \"[\".concat(newValue.length - 1, \"]\"), value);\n    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);\n    fields.value.push(createEntry(value));\n    updateEntryFlags();\n  }\n\n  function swap(indexA, indexB) {\n    var pathName = unref(arrayPath);\n    var pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n\n    if (!Array.isArray(pathValue) || !(indexA in pathValue) || !(indexB in pathValue)) {\n      return;\n    }\n\n    var newValue = _toConsumableArray(pathValue);\n\n    var newFields = _toConsumableArray(fields.value); // the old switcheroo\n\n\n    var temp = newValue[indexA];\n    newValue[indexA] = newValue[indexB];\n    newValue[indexB] = temp;\n    var tempEntry = newFields[indexA];\n    newFields[indexA] = newFields[indexB];\n    newFields[indexB] = tempEntry;\n    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);\n    fields.value = newFields;\n    updateEntryFlags();\n  }\n\n  function insert(idx, value) {\n    var pathName = unref(arrayPath);\n    var pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n\n    if (!Array.isArray(pathValue) || pathValue.length < idx) {\n      return;\n    }\n\n    var newValue = _toConsumableArray(pathValue);\n\n    var newFields = _toConsumableArray(fields.value);\n\n    newValue.splice(idx, 0, value);\n    newFields.splice(idx, 0, createEntry(value));\n    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);\n    fields.value = newFields;\n    updateEntryFlags();\n  }\n\n  function replace(arr) {\n    var pathName = unref(arrayPath);\n    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, arr);\n    initFields();\n  }\n\n  function update(idx, value) {\n    var pathName = unref(arrayPath);\n    var pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n\n    if (!Array.isArray(pathValue) || pathValue.length - 1 < idx) {\n      return;\n    }\n\n    form === null || form === void 0 ? void 0 : form.setFieldValue(\"\".concat(pathName, \"[\").concat(idx, \"]\"), value);\n  }\n\n  function prepend(value) {\n    var pathName = unref(arrayPath);\n    var pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n    var normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;\n\n    if (!Array.isArray(normalizedPathValue)) {\n      return;\n    }\n\n    var newValue = [value].concat(_toConsumableArray(normalizedPathValue));\n    form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + \"[\".concat(newValue.length - 1, \"]\"), value);\n    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);\n    fields.value.unshift(createEntry(value));\n    updateEntryFlags();\n  }\n\n  function move(oldIdx, newIdx) {\n    var pathName = unref(arrayPath);\n    var pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n    var newValue = isNullOrUndefined(pathValue) ? [] : _toConsumableArray(pathValue);\n\n    if (!Array.isArray(pathValue) || !(oldIdx in pathValue) || !(newIdx in pathValue)) {\n      return;\n    }\n\n    var newFields = _toConsumableArray(fields.value);\n\n    var movedItem = newFields[oldIdx];\n    newFields.splice(oldIdx, 1);\n    newFields.splice(newIdx, 0, movedItem);\n    var movedValue = newValue[oldIdx];\n    newValue.splice(oldIdx, 1);\n    newValue.splice(newIdx, 0, movedValue);\n    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);\n    fields.value = newFields;\n    updateEntryFlags();\n  }\n\n  var fieldArrayCtx = {\n    fields: fields,\n    remove: remove,\n    push: push,\n    swap: swap,\n    insert: insert,\n    update: update,\n    replace: replace,\n    prepend: prepend,\n    move: move\n  };\n  form.fieldArrays.push(Object.assign({\n    path: arrayPath,\n    reset: initFields\n  }, fieldArrayCtx));\n  onBeforeUnmount(function () {\n    var idx = form.fieldArrays.findIndex(function (i) {\n      return unref(i.path) === unref(arrayPath);\n    });\n\n    if (idx >= 0) {\n      form.fieldArrays.splice(idx, 1);\n    }\n  });\n  return fieldArrayCtx;\n}\n\nvar FieldArrayImpl = defineComponent({\n  name: 'FieldArray',\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      required: true\n    }\n  },\n  setup: function setup(props, ctx) {\n    var _useFieldArray = useFieldArray(toRef(props, 'name')),\n        push = _useFieldArray.push,\n        remove = _useFieldArray.remove,\n        swap = _useFieldArray.swap,\n        insert = _useFieldArray.insert,\n        replace = _useFieldArray.replace,\n        update = _useFieldArray.update,\n        prepend = _useFieldArray.prepend,\n        move = _useFieldArray.move,\n        fields = _useFieldArray.fields;\n\n    function slotProps() {\n      return {\n        fields: fields.value,\n        push: push,\n        remove: remove,\n        swap: swap,\n        insert: insert,\n        update: update,\n        replace: replace,\n        prepend: prepend,\n        move: move\n      };\n    }\n\n    ctx.expose({\n      push: push,\n      remove: remove,\n      swap: swap,\n      insert: insert,\n      update: update,\n      replace: replace,\n      prepend: prepend,\n      move: move\n    });\n    return function () {\n      var children = normalizeChildren(undefined, ctx, slotProps);\n      return children;\n    };\n  }\n});\nvar FieldArray = FieldArrayImpl;\nvar ErrorMessageImpl = defineComponent({\n  name: 'ErrorMessage',\n  props: {\n    as: {\n      type: String,\n      \"default\": undefined\n    },\n    name: {\n      type: String,\n      required: true\n    }\n  },\n  setup: function setup(props, ctx) {\n    var form = inject(FormContextKey, undefined);\n    var message = computed(function () {\n      return form === null || form === void 0 ? void 0 : form.errors.value[props.name];\n    });\n\n    function slotProps() {\n      return {\n        message: message.value\n      };\n    }\n\n    return function () {\n      // Renders nothing if there are no messages\n      if (!message.value) {\n        return undefined;\n      }\n\n      var tag = props.as ? resolveDynamicComponent(props.as) : props.as;\n      var children = normalizeChildren(tag, ctx, slotProps);\n      var attrs = Object.assign({\n        role: 'alert'\n      }, ctx.attrs); // If no tag was specified and there are children\n      // render the slot as is without wrapping it\n\n      if (!tag && (Array.isArray(children) || !children) && (children === null || children === void 0 ? void 0 : children.length)) {\n        return children;\n      } // If no children in slot\n      // render whatever specified and fallback to a <span> with the message in it's contents\n\n\n      if ((Array.isArray(children) || !children) && !(children === null || children === void 0 ? void 0 : children.length)) {\n        return h(tag || 'span', attrs, message.value);\n      }\n\n      return h(tag, attrs, children);\n    };\n  }\n});\nvar ErrorMessage = ErrorMessageImpl;\n\nfunction useResetForm() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return function resetForm(state) {\n    if (!form) {\n      return;\n    }\n\n    return form.resetForm(state);\n  };\n}\n/**\r\n * If a field is dirty or not\r\n */\n\n\nfunction useIsFieldDirty(path) {\n  var form = injectWithSelf(FormContextKey);\n  var field = path ? undefined : inject(FieldContextKey);\n  return computed(function () {\n    if (path) {\n      field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsByPath.value[unref(path)]);\n    }\n\n    if (!field) {\n      warn(\"field with name \".concat(unref(path), \" was not found\"));\n      return false;\n    }\n\n    return field.meta.dirty;\n  });\n}\n/**\r\n * If a field is touched or not\r\n */\n\n\nfunction useIsFieldTouched(path) {\n  var form = injectWithSelf(FormContextKey);\n  var field = path ? undefined : inject(FieldContextKey);\n  return computed(function () {\n    if (path) {\n      field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsByPath.value[unref(path)]);\n    }\n\n    if (!field) {\n      warn(\"field with name \".concat(unref(path), \" was not found\"));\n      return false;\n    }\n\n    return field.meta.touched;\n  });\n}\n/**\r\n * If a field is validated and is valid\r\n */\n\n\nfunction useIsFieldValid(path) {\n  var form = injectWithSelf(FormContextKey);\n  var field = path ? undefined : inject(FieldContextKey);\n  return computed(function () {\n    if (path) {\n      field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsByPath.value[unref(path)]);\n    }\n\n    if (!field) {\n      warn(\"field with name \".concat(unref(path), \" was not found\"));\n      return false;\n    }\n\n    return field.meta.valid;\n  });\n}\n/**\r\n * If the form is submitting or not\r\n */\n\n\nfunction useIsSubmitting() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return computed(function () {\n    var _a;\n\n    return (_a = form === null || form === void 0 ? void 0 : form.isSubmitting.value) !== null && _a !== void 0 ? _a : false;\n  });\n}\n/**\r\n * Validates a single field\r\n */\n\n\nfunction useValidateField(path) {\n  var form = injectWithSelf(FormContextKey);\n  var field = path ? undefined : inject(FieldContextKey);\n  return function validateField() {\n    if (path) {\n      field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsByPath.value[unref(path)]);\n    }\n\n    if (!field) {\n      warn(\"field with name \".concat(unref(path), \" was not found\"));\n      return Promise.resolve({\n        errors: [],\n        valid: true\n      });\n    }\n\n    return field.validate();\n  };\n}\n/**\r\n * If the form is dirty or not\r\n */\n\n\nfunction useIsFormDirty() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return computed(function () {\n    var _a;\n\n    return (_a = form === null || form === void 0 ? void 0 : form.meta.value.dirty) !== null && _a !== void 0 ? _a : false;\n  });\n}\n/**\r\n * If the form is touched or not\r\n */\n\n\nfunction useIsFormTouched() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return computed(function () {\n    var _a;\n\n    return (_a = form === null || form === void 0 ? void 0 : form.meta.value.touched) !== null && _a !== void 0 ? _a : false;\n  });\n}\n/**\r\n * If the form has been validated and is valid\r\n */\n\n\nfunction useIsFormValid() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return computed(function () {\n    var _a;\n\n    return (_a = form === null || form === void 0 ? void 0 : form.meta.value.valid) !== null && _a !== void 0 ? _a : false;\n  });\n}\n/**\r\n * Validate multiple fields\r\n */\n\n\nfunction useValidateForm() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return function validateField() {\n    if (!form) {\n      return Promise.resolve({\n        results: {},\n        errors: {},\n        valid: true\n      });\n    }\n\n    return form.validate();\n  };\n}\n/**\r\n * The number of form's submission count\r\n */\n\n\nfunction useSubmitCount() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return computed(function () {\n    var _a;\n\n    return (_a = form === null || form === void 0 ? void 0 : form.submitCount.value) !== null && _a !== void 0 ? _a : 0;\n  });\n}\n/**\r\n * Gives access to a field's current value\r\n */\n\n\nfunction useFieldValue(path) {\n  var form = injectWithSelf(FormContextKey); // We don't want to use self injected context as it doesn't make sense\n\n  var field = path ? undefined : inject(FieldContextKey);\n  return computed(function () {\n    if (path) {\n      return getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(path));\n    }\n\n    return unref(field === null || field === void 0 ? void 0 : field.value);\n  });\n}\n/**\r\n * Gives access to a form's values\r\n */\n\n\nfunction useFormValues() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return computed(function () {\n    return (form === null || form === void 0 ? void 0 : form.values) || {};\n  });\n}\n/**\r\n * Gives access to all form errors\r\n */\n\n\nfunction useFormErrors() {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  return computed(function () {\n    return (form === null || form === void 0 ? void 0 : form.errors.value) || {};\n  });\n}\n/**\r\n * Gives access to a single field error\r\n */\n\n\nfunction useFieldError(path) {\n  var form = injectWithSelf(FormContextKey); // We don't want to use self injected context as it doesn't make sense\n\n  var field = path ? undefined : inject(FieldContextKey);\n  return computed(function () {\n    if (path) {\n      return form === null || form === void 0 ? void 0 : form.errors.value[unref(path)];\n    }\n\n    return field === null || field === void 0 ? void 0 : field.errorMessage.value;\n  });\n}\n\nfunction useSubmitForm(cb) {\n  var form = injectWithSelf(FormContextKey);\n\n  if (!form) {\n    warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n  }\n\n  var onSubmit = form ? form.handleSubmit(cb) : undefined;\n  return function submitForm(e) {\n    if (!onSubmit) {\n      return;\n    }\n\n    return onSubmit(e);\n  };\n}\n\nexport { ErrorMessage, Field, FieldArray, FieldContextKey, Form, FormContextKey, IS_ABSENT, configure, defineRule, useField, useFieldArray, useFieldError, useFieldValue, useForm, useFormErrors, useFormValues, useIsFieldDirty, useIsFieldTouched, useIsFieldValid, useIsFormDirty, useIsFormTouched, useIsFormValid, useIsSubmitting, useResetForm, useSubmitCount, useSubmitForm, useValidateField, useValidateForm, validate };","map":null,"metadata":{},"sourceType":"module"}