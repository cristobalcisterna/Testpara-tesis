{"ast":null,"code":"import { _ as _defineProperty, d as _toConsumableArray, b as _typeof } from './chunk-1fafdf15.js';\nimport { toCssWidth, getValueByPath, indexOf, multiColumnSort, escapeRegExpChars } from './helpers.js';\nimport { V as VueInstance, s as setVueInstance } from './chunk-652f2dad.js';\nimport './chunk-516e4877.js';\nimport { I as Icon } from './chunk-7fd02ffe.js';\nimport { _ as __vue_normalize__, r as registerComponent, u as use } from './chunk-cca88db8.js';\nimport { I as Input } from './chunk-f160efb9.js';\nimport './chunk-2793447b.js';\nimport { C as Checkbox } from './chunk-252f2b57.js';\nimport { S as Select } from './chunk-37678809.js';\nimport './chunk-b9bdb0e4.js';\nimport { L as Loading } from './chunk-ee935ae6.js';\nimport { P as Pagination } from './chunk-56040896.js';\nimport { S as SlotComponent } from './chunk-e36a4f2c.js';\n\nfunction debounce(func, wait, immediate) {\n  var timeout;\n  return function () {\n    var context = this;\n    var args = arguments;\n\n    var later = function later() {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n\nvar _components;\n\nvar script = {\n  name: 'BTableMobileSort',\n  components: (_components = {}, _defineProperty(_components, Select.name, Select), _defineProperty(_components, Icon.name, Icon), _components),\n  props: {\n    currentSortColumn: Object,\n    sortMultipleData: Array,\n    isAsc: Boolean,\n    columns: Array,\n    placeholder: String,\n    iconPack: String,\n    sortIcon: {\n      type: String,\n      \"default\": 'arrow-up'\n    },\n    sortIconSize: {\n      type: String,\n      \"default\": 'is-small'\n    },\n    sortMultiple: {\n      type: Boolean,\n      \"default\": false\n    }\n  },\n  data: function data() {\n    return {\n      sortMultipleSelect: '',\n      mobileSort: this.currentSortColumn,\n      defaultEvent: {\n        shiftKey: true,\n        altKey: true,\n        ctrlKey: true\n      },\n      ignoreSort: false\n    };\n  },\n  computed: {\n    showPlaceholder: function showPlaceholder() {\n      var _this = this;\n\n      return !this.columns || !this.columns.some(function (column) {\n        return column === _this.mobileSort;\n      });\n    }\n  },\n  watch: {\n    sortMultipleSelect: function sortMultipleSelect(column) {\n      if (this.ignoreSort) {\n        this.ignoreSort = false;\n      } else {\n        this.$emit('sort', column, this.defaultEvent);\n      }\n    },\n    mobileSort: function mobileSort(column) {\n      if (this.currentSortColumn === column) return;\n      this.$emit('sort', column, this.defaultEvent);\n    },\n    currentSortColumn: function currentSortColumn(column) {\n      this.mobileSort = column;\n    }\n  },\n  methods: {\n    removePriority: function removePriority() {\n      var _this2 = this;\n\n      this.$emit('removePriority', this.sortMultipleSelect); // ignore the watcher to sort when we just change whats displayed in the select\n      // otherwise the direction will be flipped\n      // The sort event is already triggered by the emit\n\n      this.ignoreSort = true; // Select one of the other options when we reset one\n\n      var remainingFields = this.sortMultipleData.filter(function (data) {\n        return data.field !== _this2.sortMultipleSelect.field;\n      }).map(function (data) {\n        return data.field;\n      });\n      this.sortMultipleSelect = this.columns.filter(function (column) {\n        return remainingFields.includes(column.field);\n      })[0];\n    },\n    getSortingObjectOfColumn: function getSortingObjectOfColumn(column) {\n      return this.sortMultipleData.filter(function (i) {\n        return i.field === column.field;\n      })[0];\n    },\n    columnIsDesc: function columnIsDesc(column) {\n      var sortingObject = this.getSortingObjectOfColumn(column);\n\n      if (sortingObject) {\n        return !!(sortingObject.order && sortingObject.order === 'desc');\n      }\n\n      return true;\n    },\n    getLabel: function getLabel(column) {\n      var sortingObject = this.getSortingObjectOfColumn(column);\n\n      if (sortingObject) {\n        return column.label + '(' + (this.sortMultipleData.indexOf(sortingObject) + 1) + ')';\n      }\n\n      return column.label;\n    },\n    sort: function sort() {\n      this.$emit('sort', this.sortMultiple ? this.sortMultipleSelect : this.mobileSort, this.defaultEvent);\n    }\n  }\n};\n/* script */\n\nvar __vue_script__ = script;\n/* template */\n\nvar __vue_render__ = function __vue_render__() {\n  var _vm = this;\n\n  var _h = _vm.$createElement;\n\n  var _c = _vm._self._c || _h;\n\n  return _c('div', {\n    staticClass: \"field table-mobile-sort\"\n  }, [_c('div', {\n    staticClass: \"field has-addons\"\n  }, [_vm.sortMultiple ? _c('b-select', {\n    attrs: {\n      \"expanded\": \"\"\n    },\n    model: {\n      value: _vm.sortMultipleSelect,\n      callback: function callback($$v) {\n        _vm.sortMultipleSelect = $$v;\n      },\n      expression: \"sortMultipleSelect\"\n    }\n  }, _vm._l(_vm.columns, function (column, index) {\n    return column.sortable ? _c('option', {\n      key: index,\n      domProps: {\n        \"value\": column\n      }\n    }, [_vm._v(\" \" + _vm._s(_vm.getLabel(column)) + \" \"), _vm.getSortingObjectOfColumn(column) ? [_vm.columnIsDesc(column) ? [_vm._v(\" ↓ \")] : [_vm._v(\" ↑ \")]] : _vm._e()], 2) : _vm._e();\n  }), 0) : _c('b-select', {\n    attrs: {\n      \"expanded\": \"\"\n    },\n    model: {\n      value: _vm.mobileSort,\n      callback: function callback($$v) {\n        _vm.mobileSort = $$v;\n      },\n      expression: \"mobileSort\"\n    }\n  }, [_vm.placeholder ? [_c('option', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: _vm.showPlaceholder,\n      expression: \"showPlaceholder\"\n    }],\n    attrs: {\n      \"selected\": \"\",\n      \"disabled\": \"\",\n      \"hidden\": \"\"\n    },\n    domProps: {\n      \"value\": {}\n    }\n  }, [_vm._v(\" \" + _vm._s(_vm.placeholder) + \" \")])] : _vm._e(), _vm._l(_vm.columns, function (column, index) {\n    return column.sortable ? _c('option', {\n      key: index,\n      domProps: {\n        \"value\": column\n      }\n    }, [_vm._v(\" \" + _vm._s(column.label) + \" \")]) : _vm._e();\n  })], 2), _c('div', {\n    staticClass: \"control\"\n  }, [_vm.sortMultiple && _vm.sortMultipleData.length > 0 ? [_c('button', {\n    staticClass: \"button is-primary\",\n    on: {\n      \"click\": _vm.sort\n    }\n  }, [_c('b-icon', {\n    \"class\": {\n      'is-desc': _vm.columnIsDesc(_vm.sortMultipleSelect)\n    },\n    attrs: {\n      \"icon\": _vm.sortIcon,\n      \"pack\": _vm.iconPack,\n      \"size\": _vm.sortIconSize,\n      \"both\": \"\"\n    }\n  })], 1), _c('button', {\n    staticClass: \"button is-primary\",\n    on: {\n      \"click\": _vm.removePriority\n    }\n  }, [_c('b-icon', {\n    attrs: {\n      \"icon\": \"delete\",\n      \"size\": _vm.sortIconSize,\n      \"both\": \"\"\n    }\n  })], 1)] : !_vm.sortMultiple ? _c('button', {\n    staticClass: \"button is-primary\",\n    on: {\n      \"click\": _vm.sort\n    }\n  }, [_c('b-icon', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: _vm.currentSortColumn === _vm.mobileSort,\n      expression: \"currentSortColumn === mobileSort\"\n    }],\n    \"class\": {\n      'is-desc': !_vm.isAsc\n    },\n    attrs: {\n      \"icon\": _vm.sortIcon,\n      \"pack\": _vm.iconPack,\n      \"size\": _vm.sortIconSize,\n      \"both\": \"\"\n    }\n  })], 1) : _vm._e()], 2)], 1)]);\n};\n\nvar __vue_staticRenderFns__ = [];\n/* style */\n\nvar __vue_inject_styles__ = undefined;\n/* scoped */\n\nvar __vue_scope_id__ = undefined;\n/* module identifier */\n\nvar __vue_module_identifier__ = undefined;\n/* functional template */\n\nvar __vue_is_functional_template__ = false;\n/* style inject */\n\n/* style inject SSR */\n\nvar TableMobileSort = __vue_normalize__({\n  render: __vue_render__,\n  staticRenderFns: __vue_staticRenderFns__\n}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);\n\nvar script$1 = {\n  name: 'BTableColumn',\n  inject: {\n    $table: {\n      name: '$table',\n      \"default\": false\n    }\n  },\n  props: {\n    label: String,\n    customKey: [String, Number],\n    field: String,\n    meta: [String, Number, Boolean, Function, Object, Array],\n    width: [Number, String],\n    numeric: Boolean,\n    centered: Boolean,\n    searchable: Boolean,\n    sortable: Boolean,\n    visible: {\n      type: Boolean,\n      \"default\": true\n    },\n    subheading: [String, Number],\n    customSort: Function,\n    customSearch: Function,\n    sticky: Boolean,\n    headerSelectable: Boolean,\n    headerClass: String,\n    cellClass: String,\n    thAttrs: {\n      type: Function,\n      \"default\": function _default() {\n        return {};\n      }\n    },\n    tdAttrs: {\n      type: Function,\n      \"default\": function _default() {\n        return {};\n      }\n    }\n  },\n  data: function data() {\n    return {\n      newKey: this.customKey || this.label,\n      _isTableColumn: true\n    };\n  },\n  computed: {\n    thClasses: function thClasses() {\n      var attrs = this.thAttrs(this);\n      var classes = [this.headerClass, {\n        'is-sortable': this.sortable,\n        'is-sticky': this.sticky,\n        'is-unselectable': this.isHeaderUnSelectable\n      }];\n\n      if (attrs && attrs[\"class\"]) {\n        classes.push(attrs[\"class\"]);\n      }\n\n      return classes;\n    },\n    thStyle: function thStyle() {\n      var attrs = this.thAttrs(this);\n      var style = [this.style];\n\n      if (attrs && attrs.style) {\n        style.push(attrs.style);\n      }\n\n      return style;\n    },\n    rootClasses: function rootClasses() {\n      return [this.cellClass, {\n        'has-text-right': this.numeric && !this.centered,\n        'has-text-centered': this.centered,\n        'is-sticky': this.sticky\n      }];\n    },\n    style: function style() {\n      return {\n        width: toCssWidth(this.width)\n      };\n    },\n    hasDefaultSlot: function hasDefaultSlot() {\n      return !!this.$scopedSlots[\"default\"];\n    },\n\n    /**\r\n     * Return if column header is un-selectable\r\n     */\n    isHeaderUnSelectable: function isHeaderUnSelectable() {\n      return !this.headerSelectable && this.sortable;\n    }\n  },\n  methods: {\n    getRootClasses: function getRootClasses(row) {\n      var attrs = this.tdAttrs(row, this);\n      var classes = [this.rootClasses];\n\n      if (attrs && attrs[\"class\"]) {\n        classes.push(attrs[\"class\"]);\n      }\n\n      return classes;\n    },\n    getRootStyle: function getRootStyle(row) {\n      var attrs = this.tdAttrs(row, this);\n      var style = [];\n\n      if (attrs && attrs.style) {\n        style.push(attrs.style);\n      }\n\n      return style;\n    }\n  },\n  created: function created() {\n    if (!this.$table) {\n      this.$destroy();\n      throw new Error('You should wrap bTableColumn on a bTable');\n    }\n\n    this.$table.refreshSlots();\n  },\n  render: function render(createElement) {\n    // renderless\n    return null;\n  }\n};\n/* script */\n\nvar __vue_script__$1 = script$1;\n/* template */\n\n/* style */\n\nvar __vue_inject_styles__$1 = undefined;\n/* scoped */\n\nvar __vue_scope_id__$1 = undefined;\n/* module identifier */\n\nvar __vue_module_identifier__$1 = undefined;\n/* functional template */\n\nvar __vue_is_functional_template__$1 = undefined;\n/* style inject */\n\n/* style inject SSR */\n\nvar TableColumn = __vue_normalize__({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, undefined, undefined);\n\nvar script$2 = {\n  name: 'BTablePagination',\n  components: _defineProperty({}, Pagination.name, Pagination),\n  props: {\n    paginated: Boolean,\n    total: [Number, String],\n    perPage: [Number, String],\n    currentPage: [Number, String],\n    paginationSimple: Boolean,\n    paginationSize: String,\n    rounded: Boolean,\n    iconPack: String,\n    ariaNextLabel: String,\n    ariaPreviousLabel: String,\n    ariaPageLabel: String,\n    ariaCurrentLabel: String\n  },\n  data: function data() {\n    return {\n      newCurrentPage: this.currentPage\n    };\n  },\n  watch: {\n    currentPage: function currentPage(newVal) {\n      this.newCurrentPage = newVal;\n    }\n  },\n  methods: {\n    /**\r\n    * Paginator change listener.\r\n    */\n    pageChanged: function pageChanged(page) {\n      this.newCurrentPage = page > 0 ? page : 1;\n      this.$emit('update:currentPage', this.newCurrentPage);\n      this.$emit('page-change', this.newCurrentPage);\n    }\n  }\n};\n/* script */\n\nvar __vue_script__$2 = script$2;\n/* template */\n\nvar __vue_render__$1 = function __vue_render__$1() {\n  var _vm = this;\n\n  var _h = _vm.$createElement;\n\n  var _c = _vm._self._c || _h;\n\n  return _c('div', {\n    staticClass: \"top level\"\n  }, [_c('div', {\n    staticClass: \"level-left\"\n  }, [_vm._t(\"default\")], 2), _c('div', {\n    staticClass: \"level-right\"\n  }, [_vm.paginated ? _c('div', {\n    staticClass: \"level-item\"\n  }, [_c('b-pagination', {\n    attrs: {\n      \"icon-pack\": _vm.iconPack,\n      \"total\": _vm.total,\n      \"per-page\": _vm.perPage,\n      \"simple\": _vm.paginationSimple,\n      \"size\": _vm.paginationSize,\n      \"current\": _vm.newCurrentPage,\n      \"rounded\": _vm.rounded,\n      \"aria-next-label\": _vm.ariaNextLabel,\n      \"aria-previous-label\": _vm.ariaPreviousLabel,\n      \"aria-page-label\": _vm.ariaPageLabel,\n      \"aria-current-label\": _vm.ariaCurrentLabel\n    },\n    on: {\n      \"change\": _vm.pageChanged\n    }\n  })], 1) : _vm._e()])]);\n};\n\nvar __vue_staticRenderFns__$1 = [];\n/* style */\n\nvar __vue_inject_styles__$2 = undefined;\n/* scoped */\n\nvar __vue_scope_id__$2 = undefined;\n/* module identifier */\n\nvar __vue_module_identifier__$2 = undefined;\n/* functional template */\n\nvar __vue_is_functional_template__$2 = false;\n/* style inject */\n\n/* style inject SSR */\n\nvar TablePagination = __vue_normalize__({\n  render: __vue_render__$1,\n  staticRenderFns: __vue_staticRenderFns__$1\n}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, undefined, undefined);\n\nvar _components$1;\n\nvar script$3 = {\n  name: 'BTable',\n  components: (_components$1 = {}, _defineProperty(_components$1, Checkbox.name, Checkbox), _defineProperty(_components$1, Icon.name, Icon), _defineProperty(_components$1, Input.name, Input), _defineProperty(_components$1, Loading.name, Loading), _defineProperty(_components$1, SlotComponent.name, SlotComponent), _defineProperty(_components$1, TableMobileSort.name, TableMobileSort), _defineProperty(_components$1, TableColumn.name, TableColumn), _defineProperty(_components$1, TablePagination.name, TablePagination), _components$1),\n  inheritAttrs: false,\n  provide: function provide() {\n    return {\n      $table: this\n    };\n  },\n  props: {\n    data: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    columns: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    bordered: Boolean,\n    striped: Boolean,\n    narrowed: Boolean,\n    hoverable: Boolean,\n    loading: Boolean,\n    detailed: Boolean,\n    checkable: Boolean,\n    headerCheckable: {\n      type: Boolean,\n      \"default\": true\n    },\n    checkboxPosition: {\n      type: String,\n      \"default\": 'left',\n      validator: function validator(value) {\n        return ['left', 'right'].indexOf(value) >= 0;\n      }\n    },\n    stickyCheckbox: {\n      type: Boolean,\n      \"default\": false\n    },\n    selected: Object,\n    isRowSelectable: {\n      type: Function,\n      \"default\": function _default() {\n        return true;\n      }\n    },\n    focusable: Boolean,\n    customIsChecked: Function,\n    isRowCheckable: {\n      type: Function,\n      \"default\": function _default() {\n        return true;\n      }\n    },\n    checkedRows: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    mobileCards: {\n      type: Boolean,\n      \"default\": true\n    },\n    defaultSort: [String, Array],\n    defaultSortDirection: {\n      type: String,\n      \"default\": 'asc'\n    },\n    sortIcon: {\n      type: String,\n      \"default\": 'arrow-up'\n    },\n    sortIconSize: {\n      type: String,\n      \"default\": 'is-small'\n    },\n    sortMultiple: {\n      type: Boolean,\n      \"default\": false\n    },\n    sortMultipleData: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    sortMultipleKey: {\n      type: String,\n      \"default\": null\n    },\n    paginated: Boolean,\n    currentPage: {\n      type: Number,\n      \"default\": 1\n    },\n    perPage: {\n      type: [Number, String],\n      \"default\": 20\n    },\n    showDetailIcon: {\n      type: Boolean,\n      \"default\": true\n    },\n    detailIcon: {\n      type: String,\n      \"default\": 'chevron-right'\n    },\n    paginationPosition: {\n      type: String,\n      \"default\": 'bottom',\n      validator: function validator(value) {\n        return ['bottom', 'top', 'both'].indexOf(value) >= 0;\n      }\n    },\n    paginationRounded: Boolean,\n    backendSorting: Boolean,\n    backendFiltering: Boolean,\n    rowClass: {\n      type: Function,\n      \"default\": function _default() {\n        return '';\n      }\n    },\n    openedDetailed: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    hasDetailedVisible: {\n      type: Function,\n      \"default\": function _default() {\n        return true;\n      }\n    },\n    detailKey: {\n      type: String,\n      \"default\": ''\n    },\n    detailTransition: {\n      type: String,\n      \"default\": ''\n    },\n    customDetailRow: {\n      type: Boolean,\n      \"default\": false\n    },\n    backendPagination: Boolean,\n    total: {\n      type: [Number, String],\n      \"default\": 0\n    },\n    iconPack: String,\n    mobileSortPlaceholder: String,\n    customRowKey: String,\n    draggable: {\n      type: Boolean,\n      \"default\": false\n    },\n    draggableColumn: {\n      type: Boolean,\n      \"default\": false\n    },\n    scrollable: Boolean,\n    ariaNextLabel: String,\n    ariaPreviousLabel: String,\n    ariaPageLabel: String,\n    ariaCurrentLabel: String,\n    stickyHeader: Boolean,\n    height: [Number, String],\n    filtersEvent: {\n      type: String,\n      \"default\": ''\n    },\n    cardLayout: Boolean,\n    showHeader: {\n      type: Boolean,\n      \"default\": true\n    },\n    debounceSearch: Number,\n    caption: String,\n    showCaption: {\n      type: Boolean,\n      \"default\": true\n    }\n  },\n  data: function data() {\n    return {\n      sortMultipleDataLocal: [],\n      getValueByPath: getValueByPath,\n      visibleDetailRows: this.openedDetailed,\n      newData: this.data,\n      newDataTotal: this.backendPagination ? this.total : this.data.length,\n      newCheckedRows: _toConsumableArray(this.checkedRows),\n      lastCheckedRowIndex: null,\n      newCurrentPage: this.currentPage,\n      currentSortColumn: {},\n      isAsc: true,\n      filters: {},\n      defaultSlots: [],\n      firstTimeSort: true,\n      // Used by first time initSort\n      _isTable: true,\n      // Used by TableColumn\n      isDraggingRow: false,\n      isDraggingColumn: false\n    };\n  },\n  computed: {\n    sortMultipleDataComputed: function sortMultipleDataComputed() {\n      return this.backendSorting ? this.sortMultipleData : this.sortMultipleDataLocal;\n    },\n    tableClasses: function tableClasses() {\n      return {\n        'is-bordered': this.bordered,\n        'is-striped': this.striped,\n        'is-narrow': this.narrowed,\n        'is-hoverable': (this.hoverable || this.focusable) && this.visibleData.length\n      };\n    },\n    tableWrapperClasses: function tableWrapperClasses() {\n      return {\n        'has-mobile-cards': this.mobileCards,\n        'has-sticky-header': this.stickyHeader,\n        'is-card-list': this.cardLayout,\n        'table-container': this.isScrollable\n      };\n    },\n    tableStyle: function tableStyle() {\n      return {\n        height: toCssWidth(this.height)\n      };\n    },\n\n    /**\r\n    * Splitted data based on the pagination.\r\n    */\n    visibleData: function visibleData() {\n      if (!this.paginated) return this.newData;\n      var currentPage = this.newCurrentPage;\n      var perPage = this.perPage;\n\n      if (this.newData.length <= perPage) {\n        return this.newData;\n      } else {\n        var start = (currentPage - 1) * perPage;\n        var end = parseInt(start, 10) + parseInt(perPage, 10);\n        return this.newData.slice(start, end);\n      }\n    },\n    visibleColumns: function visibleColumns() {\n      if (!this.newColumns) return this.newColumns;\n      return this.newColumns.filter(function (column) {\n        return column.visible || column.visible === undefined;\n      });\n    },\n\n    /**\r\n    * Check if all rows in the page are checked.\r\n    */\n    isAllChecked: function isAllChecked() {\n      var _this = this;\n\n      var validVisibleData = this.visibleData.filter(function (row) {\n        return _this.isRowCheckable(row);\n      });\n      if (validVisibleData.length === 0) return false;\n      var isAllChecked = validVisibleData.some(function (currentVisibleRow) {\n        return indexOf(_this.newCheckedRows, currentVisibleRow, _this.customIsChecked) < 0;\n      });\n      return !isAllChecked;\n    },\n\n    /**\r\n    * Check if all rows in the page are checkable.\r\n    */\n    isAllUncheckable: function isAllUncheckable() {\n      var _this2 = this;\n\n      var validVisibleData = this.visibleData.filter(function (row) {\n        return _this2.isRowCheckable(row);\n      });\n      return validVisibleData.length === 0;\n    },\n\n    /**\r\n    * Check if has any sortable column.\r\n    */\n    hasSortablenewColumns: function hasSortablenewColumns() {\n      return this.newColumns.some(function (column) {\n        return column.sortable;\n      });\n    },\n\n    /**\r\n    * Check if has any searchable column.\r\n    */\n    hasSearchablenewColumns: function hasSearchablenewColumns() {\n      return this.newColumns.some(function (column) {\n        return column.searchable;\n      });\n    },\n\n    /**\r\n    * Check if has any column using subheading.\r\n    */\n    hasCustomSubheadings: function hasCustomSubheadings() {\n      if (this.$scopedSlots && this.$scopedSlots.subheading) return true;\n      return this.newColumns.some(function (column) {\n        return column.subheading || column.$scopedSlots && column.$scopedSlots.subheading;\n      });\n    },\n\n    /**\r\n    * Return total column count based if it's checkable or expanded\r\n    */\n    columnCount: function columnCount() {\n      var count = this.visibleColumns.length;\n      count += this.checkable ? 1 : 0;\n      count += this.detailed && this.showDetailIcon ? 1 : 0;\n      return count;\n    },\n\n    /**\r\n    * return if detailed row tabled\r\n    * will be with chevron column & icon or not\r\n    */\n    showDetailRowIcon: function showDetailRowIcon() {\n      return this.detailed && this.showDetailIcon;\n    },\n\n    /**\r\n    * return if scrollable table\r\n    */\n    isScrollable: function isScrollable() {\n      if (this.scrollable) return true;\n      if (!this.newColumns) return false;\n      return this.newColumns.some(function (column) {\n        return column.sticky;\n      });\n    },\n    newColumns: function newColumns() {\n      var _this3 = this;\n\n      if (this.columns && this.columns.length) {\n        return this.columns.map(function (column) {\n          var TableColumnComponent = VueInstance.extend(TableColumn);\n          var component = new TableColumnComponent({\n            parent: _this3,\n            propsData: column\n          });\n          component.$scopedSlots = {\n            \"default\": function _default(props) {\n              var vnode = component.$createElement('span', {\n                domProps: {\n                  innerHTML: getValueByPath(props.row, column.field)\n                }\n              });\n              return [vnode];\n            }\n          };\n          return component;\n        });\n      }\n\n      return this.defaultSlots.filter(function (vnode) {\n        return vnode.componentInstance && vnode.componentInstance.$data && vnode.componentInstance.$data._isTableColumn;\n      }).map(function (vnode) {\n        return vnode.componentInstance;\n      });\n    },\n    canDragRow: function canDragRow() {\n      return this.draggable && !this.isDraggingColumn;\n    },\n    canDragColumn: function canDragColumn() {\n      return this.draggableColumn && !this.isDraggingRow;\n    }\n  },\n  watch: {\n    /**\r\n    * When data prop change:\r\n    *   1. Update internal value.\r\n    *   2. Filter data if it's not backend-filtered.\r\n    *   3. Sort again if it's not backend-sorted.\r\n    *   4. Set new total if it's not backend-paginated.\r\n    */\n    data: function data(value) {\n      var _this4 = this;\n\n      this.newData = value;\n\n      if (!this.backendFiltering) {\n        this.newData = value.filter(function (row) {\n          return _this4.isRowFiltered(row);\n        });\n      }\n\n      if (!this.backendSorting) {\n        this.sort(this.currentSortColumn, true);\n      }\n\n      if (!this.backendPagination) {\n        this.newDataTotal = this.newData.length;\n      }\n    },\n\n    /**\r\n    * When Pagination total change, update internal total\r\n    * only if it's backend-paginated.\r\n    */\n    total: function total(newTotal) {\n      if (!this.backendPagination) return;\n      this.newDataTotal = newTotal;\n    },\n    currentPage: function currentPage(newVal) {\n      this.newCurrentPage = newVal;\n    },\n    newCurrentPage: function newCurrentPage(newVal) {\n      this.$emit('update:currentPage', newVal);\n    },\n\n    /**\r\n    * When checkedRows prop change, update internal value without\r\n    * mutating original data.\r\n    */\n    checkedRows: function checkedRows(rows) {\n      this.newCheckedRows = _toConsumableArray(rows);\n    },\n\n    /*\r\n    newColumns(value) {\r\n        this.checkSort()\r\n    },\r\n    */\n    debounceSearch: {\n      handler: function handler(value) {\n        this.debouncedHandleFiltersChange = debounce(this.handleFiltersChange, value);\n      },\n      immediate: true\n    },\n    filters: {\n      handler: function handler(value) {\n        if (this.debounceSearch) {\n          this.debouncedHandleFiltersChange(value);\n        } else {\n          this.handleFiltersChange(value);\n        }\n      },\n      deep: true\n    },\n\n    /**\r\n    * When the user wants to control the detailed rows via props.\r\n    * Or wants to open the details of certain row with the router for example.\r\n    */\n    openedDetailed: function openedDetailed(expandedRows) {\n      this.visibleDetailRows = expandedRows;\n    }\n  },\n  methods: {\n    onFiltersEvent: function onFiltersEvent(event) {\n      this.$emit(\"filters-event-\".concat(this.filtersEvent), {\n        event: event,\n        filters: this.filters\n      });\n    },\n    handleFiltersChange: function handleFiltersChange(value) {\n      var _this5 = this;\n\n      if (this.backendFiltering) {\n        this.$emit('filters-change', value);\n      } else {\n        this.newData = this.data.filter(function (row) {\n          return _this5.isRowFiltered(row);\n        });\n\n        if (!this.backendPagination) {\n          this.newDataTotal = this.newData.length;\n        }\n\n        if (!this.backendSorting) {\n          if (this.sortMultiple && this.sortMultipleDataLocal && this.sortMultipleDataLocal.length > 0) {\n            this.doSortMultiColumn();\n          } else if (Object.keys(this.currentSortColumn).length > 0) {\n            this.doSortSingleColumn(this.currentSortColumn);\n          }\n        }\n      }\n    },\n    findIndexOfSortData: function findIndexOfSortData(column) {\n      var sortObj = this.sortMultipleDataComputed.filter(function (i) {\n        return i.field === column.field;\n      })[0];\n      return this.sortMultipleDataComputed.indexOf(sortObj) + 1;\n    },\n    removeSortingPriority: function removeSortingPriority(column) {\n      if (this.backendSorting) {\n        this.$emit('sorting-priority-removed', column.field);\n      } else {\n        this.sortMultipleDataLocal = this.sortMultipleDataLocal.filter(function (priority) {\n          return priority.field !== column.field;\n        });\n        var formattedSortingPriority = this.sortMultipleDataLocal.map(function (i) {\n          return (i.order && i.order === 'desc' ? '-' : '') + i.field;\n        });\n        this.newData = multiColumnSort(this.newData, formattedSortingPriority);\n      }\n    },\n    resetMultiSorting: function resetMultiSorting() {\n      this.sortMultipleDataLocal = [];\n      this.currentSortColumn = {};\n      this.newData = this.data;\n    },\n\n    /**\r\n    * Sort an array by key without mutating original data.\r\n    * Call the user sort function if it was passed.\r\n    */\n    sortBy: function sortBy(array, key, fn, isAsc) {\n      var sorted = []; // Sorting without mutating original data\n\n      if (fn && typeof fn === 'function') {\n        sorted = _toConsumableArray(array).sort(function (a, b) {\n          return fn(a, b, isAsc);\n        });\n      } else {\n        sorted = _toConsumableArray(array).sort(function (a, b) {\n          // Get nested values from objects\n          var newA = getValueByPath(a, key);\n          var newB = getValueByPath(b, key); // sort boolean type\n\n          if (typeof newA === 'boolean' && typeof newB === 'boolean') {\n            return isAsc ? newA - newB : newB - newA;\n          }\n\n          if (!newA && newA !== 0) return 1;\n          if (!newB && newB !== 0) return -1;\n          if (newA === newB) return 0;\n          newA = typeof newA === 'string' ? newA.toUpperCase() : newA;\n          newB = typeof newB === 'string' ? newB.toUpperCase() : newB;\n          return isAsc ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;\n        });\n      }\n\n      return sorted;\n    },\n    sortMultiColumn: function sortMultiColumn(column) {\n      this.currentSortColumn = {};\n\n      if (!this.backendSorting) {\n        var existingPriority = this.sortMultipleDataLocal.filter(function (i) {\n          return i.field === column.field;\n        })[0];\n\n        if (existingPriority) {\n          existingPriority.order = existingPriority.order === 'desc' ? 'asc' : 'desc';\n        } else {\n          this.sortMultipleDataLocal.push({\n            field: column.field,\n            order: column.isAsc\n          });\n        }\n\n        this.doSortMultiColumn();\n      }\n    },\n    doSortMultiColumn: function doSortMultiColumn() {\n      var formattedSortingPriority = this.sortMultipleDataLocal.map(function (i) {\n        return (i.order && i.order === 'desc' ? '-' : '') + i.field;\n      });\n      this.newData = multiColumnSort(this.newData, formattedSortingPriority);\n    },\n\n    /**\r\n    * Sort the column.\r\n    * Toggle current direction on column if it's sortable\r\n    * and not just updating the prop.\r\n    */\n    sort: function sort(column) {\n      var updatingData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var event = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (!column || !column.sortable) return;\n\n      if ( // if backend sorting is enabled, just emit the sort press like usual\n      // if the correct key combination isnt pressed, sort like usual\n      !this.backendSorting && this.sortMultiple && (this.sortMultipleKey && event[this.sortMultipleKey] || !this.sortMultipleKey)) {\n        if (updatingData) {\n          this.doSortMultiColumn();\n        } else {\n          this.sortMultiColumn(column);\n        }\n      } else {\n        // sort multiple is enabled but the correct key combination isnt pressed so reset\n        if (this.sortMultiple) {\n          this.sortMultipleDataLocal = [];\n        }\n\n        if (!updatingData) {\n          this.isAsc = column === this.currentSortColumn ? !this.isAsc : this.defaultSortDirection.toLowerCase() !== 'desc';\n        }\n\n        if (!this.firstTimeSort) {\n          this.$emit('sort', column.field, this.isAsc ? 'asc' : 'desc', event);\n        }\n\n        if (!this.backendSorting) {\n          this.doSortSingleColumn(column);\n        }\n\n        this.currentSortColumn = column;\n      }\n    },\n    doSortSingleColumn: function doSortSingleColumn(column) {\n      this.newData = this.sortBy(this.newData, column.field, column.customSort, this.isAsc);\n    },\n    isRowSelected: function isRowSelected(row, selected) {\n      if (!selected) {\n        return false;\n      }\n\n      if (this.customRowKey) {\n        return row[this.customRowKey] === selected[this.customRowKey];\n      }\n\n      return row === selected;\n    },\n\n    /**\r\n    * Check if the row is checked (is added to the array).\r\n    */\n    isRowChecked: function isRowChecked(row) {\n      return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0;\n    },\n\n    /**\r\n    * Remove a checked row from the array.\r\n    */\n    removeCheckedRow: function removeCheckedRow(row) {\n      var index = indexOf(this.newCheckedRows, row, this.customIsChecked);\n\n      if (index >= 0) {\n        this.newCheckedRows.splice(index, 1);\n      }\n    },\n\n    /**\r\n    * Header checkbox click listener.\r\n    * Add or remove all rows in current page.\r\n    */\n    checkAll: function checkAll() {\n      var _this6 = this;\n\n      var isAllChecked = this.isAllChecked;\n      this.visibleData.forEach(function (currentRow) {\n        if (_this6.isRowCheckable(currentRow)) {\n          _this6.removeCheckedRow(currentRow);\n        }\n\n        if (!isAllChecked) {\n          if (_this6.isRowCheckable(currentRow)) {\n            _this6.newCheckedRows.push(currentRow);\n          }\n        }\n      });\n      this.$emit('check', this.newCheckedRows);\n      this.$emit('check-all', this.newCheckedRows); // Emit checked rows to update user variable\n\n      this.$emit('update:checkedRows', this.newCheckedRows);\n    },\n\n    /**\r\n    * Row checkbox click listener.\r\n    */\n    checkRow: function checkRow(row, index, event) {\n      if (!this.isRowCheckable(row)) return;\n      var lastIndex = this.lastCheckedRowIndex;\n      this.lastCheckedRowIndex = index;\n\n      if (event.shiftKey && lastIndex !== null && index !== lastIndex) {\n        this.shiftCheckRow(row, index, lastIndex);\n      } else if (!this.isRowChecked(row)) {\n        this.newCheckedRows.push(row);\n      } else {\n        this.removeCheckedRow(row);\n      }\n\n      this.$emit('check', this.newCheckedRows, row); // Emit checked rows to update user variable\n\n      this.$emit('update:checkedRows', this.newCheckedRows);\n    },\n\n    /**\r\n     * Check row when shift is pressed.\r\n     */\n    shiftCheckRow: function shiftCheckRow(row, index, lastCheckedRowIndex) {\n      var _this7 = this; // Get the subset of the list between the two indicies\n\n\n      var subset = this.visibleData.slice(Math.min(index, lastCheckedRowIndex), Math.max(index, lastCheckedRowIndex) + 1); // Determine the operation based on the state of the clicked checkbox\n\n      var shouldCheck = !this.isRowChecked(row);\n      subset.forEach(function (item) {\n        _this7.removeCheckedRow(item);\n\n        if (shouldCheck && _this7.isRowCheckable(item)) {\n          _this7.newCheckedRows.push(item);\n        }\n      });\n    },\n\n    /**\r\n    * Row click listener.\r\n    * Emit all necessary events.\r\n    */\n    selectRow: function selectRow(row, index) {\n      this.$emit('click', row);\n      if (this.selected === row) return;\n      if (!this.isRowSelectable(row)) return; // Emit new and old row\n\n      this.$emit('select', row, this.selected); // Emit new row to update user variable\n\n      this.$emit('update:selected', row);\n    },\n\n    /**\r\n    * Toggle to show/hide details slot\r\n    */\n    toggleDetails: function toggleDetails(obj) {\n      var found = this.isVisibleDetailRow(obj);\n\n      if (found) {\n        this.closeDetailRow(obj);\n        this.$emit('details-close', obj);\n      } else {\n        this.openDetailRow(obj);\n        this.$emit('details-open', obj);\n      } // Syncs the detailed rows with the parent component\n\n\n      this.$emit('update:openedDetailed', this.visibleDetailRows);\n    },\n    openDetailRow: function openDetailRow(obj) {\n      var index = this.handleDetailKey(obj);\n      this.visibleDetailRows.push(index);\n    },\n    closeDetailRow: function closeDetailRow(obj) {\n      var index = this.handleDetailKey(obj);\n      var i = this.visibleDetailRows.indexOf(index);\n\n      if (i >= 0) {\n        this.visibleDetailRows.splice(i, 1);\n      }\n    },\n    isVisibleDetailRow: function isVisibleDetailRow(obj) {\n      var index = this.handleDetailKey(obj);\n      return this.visibleDetailRows.indexOf(index) >= 0;\n    },\n    isActiveDetailRow: function isActiveDetailRow(row) {\n      return this.detailed && !this.customDetailRow && this.isVisibleDetailRow(row);\n    },\n    isActiveCustomDetailRow: function isActiveCustomDetailRow(row) {\n      return this.detailed && this.customDetailRow && this.isVisibleDetailRow(row);\n    },\n    isRowFiltered: function isRowFiltered(row) {\n      var _this8 = this;\n\n      var _loop = function _loop(key) {\n        // remove key if empty\n        if (!_this8.filters[key]) {\n          delete _this8.filters[key];\n          return {\n            v: true\n          };\n        }\n\n        var input = _this8.filters[key];\n\n        var column = _this8.newColumns.filter(function (c) {\n          return c.field === key;\n        })[0];\n\n        if (column && column.customSearch && typeof column.customSearch === 'function') {\n          if (!column.customSearch(row, input)) return {\n            v: false\n          };\n        } else {\n          var value = _this8.getValueByPath(row, key);\n\n          if (value == null) return {\n            v: false\n          };\n\n          if (Number.isInteger(value)) {\n            if (value !== Number(input)) return {\n              v: false\n            };\n          } else {\n            var re = new RegExp(escapeRegExpChars(input), 'i');\n            if (!re.test(value)) return {\n              v: false\n            };\n          }\n        }\n      };\n\n      for (var key in this.filters) {\n        var _ret = _loop(key);\n\n        if (_typeof(_ret) === \"object\") return _ret.v;\n      }\n\n      return true;\n    },\n\n    /**\r\n    * When the detailKey is defined we use the object[detailKey] as index.\r\n    * If not, use the object reference by default.\r\n    */\n    handleDetailKey: function handleDetailKey(index) {\n      var key = this.detailKey;\n      return !key.length || !index ? index : index[key];\n    },\n    checkPredefinedDetailedRows: function checkPredefinedDetailedRows() {\n      var defaultExpandedRowsDefined = this.openedDetailed.length > 0;\n\n      if (defaultExpandedRowsDefined && !this.detailKey.length) {\n        throw new Error('If you set a predefined opened-detailed, you must provide a unique key using the prop \"detail-key\"');\n      }\n    },\n\n    /**\r\n    * Call initSort only first time (For example async data).\r\n    */\n    checkSort: function checkSort() {\n      if (this.newColumns.length && this.firstTimeSort) {\n        this.initSort();\n        this.firstTimeSort = false;\n      } else if (this.newColumns.length) {\n        if (Object.keys(this.currentSortColumn).length > 0) {\n          for (var i = 0; i < this.newColumns.length; i++) {\n            if (this.newColumns[i].field === this.currentSortColumn.field) {\n              this.currentSortColumn = this.newColumns[i];\n              break;\n            }\n          }\n        }\n      }\n    },\n\n    /**\r\n    * Check if footer slot has custom content.\r\n    */\n    hasCustomFooterSlot: function hasCustomFooterSlot() {\n      if (this.$slots.footer.length > 1) return true;\n      var tag = this.$slots.footer[0].tag;\n      if (tag !== 'th' && tag !== 'td') return false;\n      return true;\n    },\n\n    /**\r\n    * Check if bottom-left slot exists.\r\n    */\n    hasBottomLeftSlot: function hasBottomLeftSlot() {\n      return typeof this.$slots['bottom-left'] !== 'undefined';\n    },\n\n    /**\r\n    * Table arrow keys listener, change selection.\r\n    */\n    pressedArrow: function pressedArrow(pos) {\n      if (!this.visibleData.length) return;\n      var index = this.visibleData.indexOf(this.selected) + pos; // Prevent from going up from first and down from last\n\n      index = index < 0 ? 0 : index > this.visibleData.length - 1 ? this.visibleData.length - 1 : index;\n      var row = this.visibleData[index];\n\n      if (!this.isRowSelectable(row)) {\n        var newIndex = null;\n\n        if (pos > 0) {\n          for (var i = index; i < this.visibleData.length && newIndex === null; i++) {\n            if (this.isRowSelectable(this.visibleData[i])) newIndex = i;\n          }\n        } else {\n          for (var _i = index; _i >= 0 && newIndex === null; _i--) {\n            if (this.isRowSelectable(this.visibleData[_i])) newIndex = _i;\n          }\n        }\n\n        if (newIndex >= 0) {\n          this.selectRow(this.visibleData[newIndex]);\n        }\n      } else {\n        this.selectRow(row);\n      }\n    },\n\n    /**\r\n    * Focus table element if has selected prop.\r\n    */\n    focus: function focus() {\n      if (!this.focusable) return;\n      this.$el.querySelector('table').focus();\n    },\n\n    /**\r\n    * Initial sorted column based on the default-sort prop.\r\n    */\n    initSort: function initSort() {\n      var _this9 = this;\n\n      if (this.sortMultiple && this.sortMultipleData) {\n        this.sortMultipleData.forEach(function (column) {\n          _this9.sortMultiColumn(column);\n        });\n      } else {\n        if (!this.defaultSort) return;\n        var sortField = '';\n        var sortDirection = this.defaultSortDirection;\n\n        if (Array.isArray(this.defaultSort)) {\n          sortField = this.defaultSort[0];\n\n          if (this.defaultSort[1]) {\n            sortDirection = this.defaultSort[1];\n          }\n        } else {\n          sortField = this.defaultSort;\n        }\n\n        var sortColumn = this.newColumns.filter(function (column) {\n          return column.field === sortField;\n        })[0];\n\n        if (sortColumn) {\n          this.isAsc = sortDirection.toLowerCase() !== 'desc';\n          this.sort(sortColumn, true);\n        }\n      }\n    },\n\n    /**\r\n    * Emits drag start event (row)\r\n    */\n    handleDragStart: function handleDragStart(event, row, index) {\n      if (!this.canDragRow) return;\n      this.isDraggingRow = true;\n      this.$emit('dragstart', {\n        event: event,\n        row: row,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drag leave event (row)\r\n    */\n    handleDragEnd: function handleDragEnd(event, row, index) {\n      if (!this.canDragRow) return;\n      this.isDraggingRow = false;\n      this.$emit('dragend', {\n        event: event,\n        row: row,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drop event (row)\r\n    */\n    handleDrop: function handleDrop(event, row, index) {\n      if (!this.canDragRow) return;\n      this.$emit('drop', {\n        event: event,\n        row: row,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drag over event (row)\r\n    */\n    handleDragOver: function handleDragOver(event, row, index) {\n      if (!this.canDragRow) return;\n      this.$emit('dragover', {\n        event: event,\n        row: row,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drag leave event (row)\r\n    */\n    handleDragLeave: function handleDragLeave(event, row, index) {\n      if (!this.canDragRow) return;\n      this.$emit('dragleave', {\n        event: event,\n        row: row,\n        index: index\n      });\n    },\n    emitEventForRow: function emitEventForRow(eventName, event, row) {\n      return this.$listeners[eventName] ? this.$emit(eventName, row, event) : null;\n    },\n\n    /**\r\n    * Emits drag start event (column)\r\n    */\n    handleColumnDragStart: function handleColumnDragStart(event, column, index) {\n      if (!this.canDragColumn) return;\n      this.isDraggingColumn = true;\n      this.$emit('columndragstart', {\n        event: event,\n        column: column,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drag leave event (column)\r\n    */\n    handleColumnDragEnd: function handleColumnDragEnd(event, column, index) {\n      if (!this.canDragColumn) return;\n      this.isDraggingColumn = false;\n      this.$emit('columndragend', {\n        event: event,\n        column: column,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drop event (column)\r\n    */\n    handleColumnDrop: function handleColumnDrop(event, column, index) {\n      if (!this.canDragColumn) return;\n      this.$emit('columndrop', {\n        event: event,\n        column: column,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drag over event (column)\r\n    */\n    handleColumnDragOver: function handleColumnDragOver(event, column, index) {\n      if (!this.canDragColumn) return;\n      this.$emit('columndragover', {\n        event: event,\n        column: column,\n        index: index\n      });\n    },\n\n    /**\r\n    * Emits drag leave event (column)\r\n    */\n    handleColumnDragLeave: function handleColumnDragLeave(event, column, index) {\n      if (!this.canDragColumn) return;\n      this.$emit('columndragleave', {\n        event: event,\n        column: column,\n        index: index\n      });\n    },\n    refreshSlots: function refreshSlots() {\n      this.defaultSlots = this.$slots[\"default\"] || [];\n    }\n  },\n  mounted: function mounted() {\n    this.refreshSlots();\n    this.checkPredefinedDetailedRows();\n    this.checkSort();\n  }\n};\n/* script */\n\nvar __vue_script__$3 = script$3;\n/* template */\n\nvar __vue_render__$2 = function __vue_render__$2() {\n  var _vm = this;\n\n  var _h = _vm.$createElement;\n\n  var _c = _vm._self._c || _h;\n\n  return _c('div', {\n    staticClass: \"b-table\"\n  }, [_vm._t(\"default\"), _vm.mobileCards && _vm.hasSortablenewColumns ? _c('b-table-mobile-sort', {\n    attrs: {\n      \"current-sort-column\": _vm.currentSortColumn,\n      \"sort-multiple\": _vm.sortMultiple,\n      \"sort-multiple-data\": _vm.sortMultipleDataComputed,\n      \"is-asc\": _vm.isAsc,\n      \"columns\": _vm.newColumns,\n      \"placeholder\": _vm.mobileSortPlaceholder,\n      \"icon-pack\": _vm.iconPack,\n      \"sort-icon\": _vm.sortIcon,\n      \"sort-icon-size\": _vm.sortIconSize\n    },\n    on: {\n      \"sort\": function sort(column, event) {\n        return _vm.sort(column, null, event);\n      },\n      \"removePriority\": function removePriority(column) {\n        return _vm.removeSortingPriority(column);\n      }\n    }\n  }) : _vm._e(), _vm.paginated && (_vm.paginationPosition === 'top' || _vm.paginationPosition === 'both') ? [_vm._t(\"pagination\", [_c('b-table-pagination', _vm._b({\n    attrs: {\n      \"per-page\": _vm.perPage,\n      \"paginated\": _vm.paginated,\n      \"rounded\": _vm.paginationRounded,\n      \"icon-pack\": _vm.iconPack,\n      \"total\": _vm.newDataTotal,\n      \"current-page\": _vm.newCurrentPage,\n      \"aria-next-label\": _vm.ariaNextLabel,\n      \"aria-previous-label\": _vm.ariaPreviousLabel,\n      \"aria-page-label\": _vm.ariaPageLabel,\n      \"aria-current-label\": _vm.ariaCurrentLabel\n    },\n    on: {\n      \"update:currentPage\": function updateCurrentPage($event) {\n        _vm.newCurrentPage = $event;\n      },\n      \"update:current-page\": function updateCurrentPage($event) {\n        _vm.newCurrentPage = $event;\n      },\n      \"page-change\": function pageChange(event) {\n        return _vm.$emit('page-change', event);\n      }\n    }\n  }, 'b-table-pagination', _vm.$attrs, false), [_vm._t(\"top-left\")], 2)])] : _vm._e(), _c('div', {\n    staticClass: \"table-wrapper\",\n    \"class\": _vm.tableWrapperClasses,\n    style: _vm.tableStyle\n  }, [_c('table', {\n    staticClass: \"table\",\n    \"class\": _vm.tableClasses,\n    attrs: {\n      \"tabindex\": !_vm.focusable ? false : 0\n    },\n    on: {\n      \"keydown\": [function ($event) {\n        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, \"up\", 38, $event.key, [\"Up\", \"ArrowUp\"])) {\n          return null;\n        }\n\n        if ($event.target !== $event.currentTarget) {\n          return null;\n        }\n\n        $event.preventDefault();\n        return _vm.pressedArrow(-1);\n      }, function ($event) {\n        if (!$event.type.indexOf('key') && _vm._k($event.keyCode, \"down\", 40, $event.key, [\"Down\", \"ArrowDown\"])) {\n          return null;\n        }\n\n        if ($event.target !== $event.currentTarget) {\n          return null;\n        }\n\n        $event.preventDefault();\n        return _vm.pressedArrow(1);\n      }]\n    }\n  }, [_vm.caption ? _c('caption', {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: _vm.showCaption,\n      expression: \"showCaption\"\n    }]\n  }, [_vm._v(_vm._s(_vm.caption))]) : _vm._e(), _vm.newColumns.length && _vm.showHeader ? _c('thead', [_c('tr', [_vm.showDetailRowIcon ? _c('th', {\n    attrs: {\n      \"width\": \"40px\"\n    }\n  }) : _vm._e(), _vm.checkable && _vm.checkboxPosition === 'left' ? _c('th', {\n    \"class\": ['checkbox-cell', {\n      'is-sticky': _vm.stickyCheckbox\n    }]\n  }, [_vm.headerCheckable ? [_c('b-checkbox', {\n    attrs: {\n      \"autocomplete\": \"off\",\n      \"value\": _vm.isAllChecked,\n      \"disabled\": _vm.isAllUncheckable\n    },\n    nativeOn: {\n      \"change\": function change($event) {\n        return _vm.checkAll($event);\n      }\n    }\n  })] : _vm._e()], 2) : _vm._e(), _vm._l(_vm.visibleColumns, function (column, index) {\n    return _c('th', _vm._b({\n      key: column.newKey + ':' + index + 'header',\n      \"class\": [column.thClasses, {\n        'is-current-sort': !_vm.sortMultiple && _vm.currentSortColumn === column\n      }],\n      style: column.thStyle,\n      attrs: {\n        \"draggable\": _vm.canDragColumn\n      },\n      on: {\n        \"click\": function click($event) {\n          $event.stopPropagation();\n          return _vm.sort(column, null, $event);\n        },\n        \"dragstart\": function dragstart($event) {\n          return _vm.handleColumnDragStart($event, column, index);\n        },\n        \"dragend\": function dragend($event) {\n          return _vm.handleColumnDragEnd($event, column, index);\n        },\n        \"drop\": function drop($event) {\n          return _vm.handleColumnDrop($event, column, index);\n        },\n        \"dragover\": function dragover($event) {\n          return _vm.handleColumnDragOver($event, column, index);\n        },\n        \"dragleave\": function dragleave($event) {\n          return _vm.handleColumnDragLeave($event, column, index);\n        }\n      }\n    }, 'th', column.thAttrs(column), false), [_c('div', {\n      staticClass: \"th-wrap\",\n      \"class\": {\n        'is-numeric': column.numeric,\n        'is-centered': column.centered\n      }\n    }, [column.$scopedSlots && column.$scopedSlots.header ? [_c('b-slot-component', {\n      attrs: {\n        \"component\": column,\n        \"scoped\": \"\",\n        \"name\": \"header\",\n        \"tag\": \"span\",\n        \"props\": {\n          column: column,\n          index: index\n        }\n      }\n    })] : [_c('span', {\n      staticClass: \"is-relative\"\n    }, [_vm._v(\" \" + _vm._s(column.label) + \" \"), _vm.sortMultiple && _vm.sortMultipleDataComputed && _vm.sortMultipleDataComputed.length > 0 && _vm.sortMultipleDataComputed.filter(function (i) {\n      return i.field === column.field;\n    }).length > 0 ? [_c('b-icon', {\n      \"class\": {\n        'is-desc': _vm.sortMultipleDataComputed.filter(function (i) {\n          return i.field === column.field;\n        })[0].order === 'desc'\n      },\n      attrs: {\n        \"icon\": _vm.sortIcon,\n        \"pack\": _vm.iconPack,\n        \"both\": \"\",\n        \"size\": _vm.sortIconSize\n      }\n    }), _vm._v(\" \" + _vm._s(_vm.findIndexOfSortData(column)) + \" \"), _c('button', {\n      staticClass: \"delete is-small multi-sort-cancel-icon\",\n      attrs: {\n        \"type\": \"button\"\n      },\n      on: {\n        \"click\": function click($event) {\n          $event.stopPropagation();\n          return _vm.removeSortingPriority(column);\n        }\n      }\n    })] : _c('b-icon', {\n      staticClass: \"sort-icon\",\n      \"class\": {\n        'is-desc': !_vm.isAsc,\n        'is-invisible': _vm.currentSortColumn !== column\n      },\n      attrs: {\n        \"icon\": _vm.sortIcon,\n        \"pack\": _vm.iconPack,\n        \"both\": \"\",\n        \"size\": _vm.sortIconSize\n      }\n    })], 2)]], 2)]);\n  }), _vm.checkable && _vm.checkboxPosition === 'right' ? _c('th', {\n    \"class\": ['checkbox-cell', {\n      'is-sticky': _vm.stickyCheckbox\n    }]\n  }, [_vm.headerCheckable ? [_c('b-checkbox', {\n    attrs: {\n      \"autocomplete\": \"off\",\n      \"value\": _vm.isAllChecked,\n      \"disabled\": _vm.isAllUncheckable\n    },\n    nativeOn: {\n      \"change\": function change($event) {\n        return _vm.checkAll($event);\n      }\n    }\n  })] : _vm._e()], 2) : _vm._e()], 2), _vm.hasCustomSubheadings ? _c('tr', {\n    staticClass: \"is-subheading\"\n  }, [_vm.showDetailRowIcon ? _c('th', {\n    attrs: {\n      \"width\": \"40px\"\n    }\n  }) : _vm._e(), _vm.checkable && _vm.checkboxPosition === 'left' ? _c('th') : _vm._e(), _vm._l(_vm.visibleColumns, function (column, index) {\n    return _c('th', {\n      key: column.newKey + ':' + index + 'subheading',\n      style: column.style\n    }, [_c('div', {\n      staticClass: \"th-wrap\",\n      \"class\": {\n        'is-numeric': column.numeric,\n        'is-centered': column.centered\n      }\n    }, [column.$scopedSlots && column.$scopedSlots.subheading ? [_c('b-slot-component', {\n      attrs: {\n        \"component\": column,\n        \"scoped\": \"\",\n        \"name\": \"subheading\",\n        \"tag\": \"span\",\n        \"props\": {\n          column: column,\n          index: index\n        }\n      }\n    })] : [_vm._v(_vm._s(column.subheading))]], 2)]);\n  }), _vm.checkable && _vm.checkboxPosition === 'right' ? _c('th') : _vm._e()], 2) : _vm._e(), _vm.hasSearchablenewColumns ? _c('tr', [_vm.showDetailRowIcon ? _c('th', {\n    attrs: {\n      \"width\": \"40px\"\n    }\n  }) : _vm._e(), _vm.checkable && _vm.checkboxPosition === 'left' ? _c('th') : _vm._e(), _vm._l(_vm.visibleColumns, function (column, index) {\n    return _c('th', _vm._b({\n      key: column.newKey + ':' + index + 'searchable',\n      \"class\": {\n        'is-sticky': column.sticky\n      },\n      style: column.thStyle\n    }, 'th', column.thAttrs(column), false), [_c('div', {\n      staticClass: \"th-wrap\"\n    }, [column.searchable ? [column.$scopedSlots && column.$scopedSlots.searchable ? [_c('b-slot-component', {\n      attrs: {\n        \"component\": column,\n        \"scoped\": true,\n        \"name\": \"searchable\",\n        \"tag\": \"span\",\n        \"props\": {\n          column: column,\n          filters: _vm.filters\n        }\n      }\n    })] : _c('b-input', {\n      attrs: {\n        \"type\": column.numeric ? 'number' : 'text'\n      },\n      nativeOn: _vm._d({}, [_vm.filtersEvent, function ($event) {\n        return _vm.onFiltersEvent($event);\n      }]),\n      model: {\n        value: _vm.filters[column.field],\n        callback: function callback($$v) {\n          _vm.$set(_vm.filters, column.field, $$v);\n        },\n        expression: \"filters[column.field]\"\n      }\n    })] : _vm._e()], 2)]);\n  }), _vm.checkable && _vm.checkboxPosition === 'right' ? _c('th') : _vm._e()], 2) : _vm._e()]) : _vm._e(), _c('tbody', [_vm._l(_vm.visibleData, function (row, index) {\n    return [_c('tr', {\n      key: _vm.customRowKey ? row[_vm.customRowKey] : index,\n      \"class\": [_vm.rowClass(row, index), {\n        'is-selected': _vm.isRowSelected(row, _vm.selected),\n        'is-checked': _vm.isRowChecked(row)\n      }],\n      attrs: {\n        \"draggable\": _vm.canDragRow\n      },\n      on: {\n        \"click\": function click($event) {\n          return _vm.selectRow(row);\n        },\n        \"dblclick\": function dblclick($event) {\n          return _vm.$emit('dblclick', row);\n        },\n        \"mouseenter\": function mouseenter($event) {\n          return _vm.emitEventForRow('mouseenter', $event, row);\n        },\n        \"mouseleave\": function mouseleave($event) {\n          return _vm.emitEventForRow('mouseleave', $event, row);\n        },\n        \"contextmenu\": function contextmenu($event) {\n          return _vm.$emit('contextmenu', row, $event);\n        },\n        \"dragstart\": function dragstart($event) {\n          return _vm.handleDragStart($event, row, index);\n        },\n        \"dragend\": function dragend($event) {\n          return _vm.handleDragEnd($event, row, index);\n        },\n        \"drop\": function drop($event) {\n          return _vm.handleDrop($event, row, index);\n        },\n        \"dragover\": function dragover($event) {\n          return _vm.handleDragOver($event, row, index);\n        },\n        \"dragleave\": function dragleave($event) {\n          return _vm.handleDragLeave($event, row, index);\n        }\n      }\n    }, [_vm.showDetailRowIcon ? _c('td', {\n      staticClass: \"chevron-cell\"\n    }, [_vm.hasDetailedVisible(row) ? _c('a', {\n      attrs: {\n        \"role\": \"button\"\n      },\n      on: {\n        \"click\": function click($event) {\n          $event.stopPropagation();\n          return _vm.toggleDetails(row);\n        }\n      }\n    }, [_c('b-icon', {\n      \"class\": {\n        'is-expanded': _vm.isVisibleDetailRow(row)\n      },\n      attrs: {\n        \"icon\": _vm.detailIcon,\n        \"pack\": _vm.iconPack,\n        \"both\": \"\"\n      }\n    })], 1) : _vm._e()]) : _vm._e(), _vm.checkable && _vm.checkboxPosition === 'left' ? _c('td', {\n      \"class\": ['checkbox-cell', {\n        'is-sticky': _vm.stickyCheckbox\n      }]\n    }, [_c('b-checkbox', {\n      attrs: {\n        \"autocomplete\": \"off\",\n        \"disabled\": !_vm.isRowCheckable(row),\n        \"value\": _vm.isRowChecked(row)\n      },\n      nativeOn: {\n        \"click\": function click($event) {\n          $event.preventDefault();\n          $event.stopPropagation();\n          return _vm.checkRow(row, index, $event);\n        }\n      }\n    })], 1) : _vm._e(), _vm._l(_vm.visibleColumns, function (column, colindex) {\n      return [column.$scopedSlots && column.$scopedSlots[\"default\"] ? [_c('b-slot-component', _vm._b({\n        key: column.newKey + ':' + index + ':' + colindex,\n        \"class\": column.getRootClasses(row),\n        style: column.getRootStyle(row),\n        attrs: {\n          \"component\": column,\n          \"scoped\": \"\",\n          \"name\": \"default\",\n          \"tag\": \"td\",\n          \"data-label\": column.label,\n          \"props\": {\n            row: row,\n            column: column,\n            index: index,\n            colindex: colindex,\n            toggleDetails: _vm.toggleDetails\n          }\n        },\n        nativeOn: {\n          \"click\": function click($event) {\n            return _vm.$emit('cellclick', row, column, index, colindex);\n          }\n        }\n      }, 'b-slot-component', column.tdAttrs(row, column), false))] : _vm._e()];\n    }), _vm.checkable && _vm.checkboxPosition === 'right' ? _c('td', {\n      \"class\": ['checkbox-cell', {\n        'is-sticky': _vm.stickyCheckbox\n      }]\n    }, [_c('b-checkbox', {\n      attrs: {\n        \"autocomplete\": \"off\",\n        \"disabled\": !_vm.isRowCheckable(row),\n        \"value\": _vm.isRowChecked(row)\n      },\n      nativeOn: {\n        \"click\": function click($event) {\n          $event.preventDefault();\n          $event.stopPropagation();\n          return _vm.checkRow(row, index, $event);\n        }\n      }\n    })], 1) : _vm._e()], 2), _c('transition', {\n      key: (_vm.customRowKey ? row[_vm.customRowKey] : index) + 'detail',\n      attrs: {\n        \"name\": _vm.detailTransition\n      }\n    }, [_vm.isActiveDetailRow(row) ? _c('tr', {\n      staticClass: \"detail\"\n    }, [_c('td', {\n      attrs: {\n        \"colspan\": _vm.columnCount\n      }\n    }, [_c('div', {\n      staticClass: \"detail-container\"\n    }, [_vm._t(\"detail\", null, {\n      \"row\": row,\n      \"index\": index\n    })], 2)])]) : _vm._e()]), _vm.isActiveCustomDetailRow(row) ? _vm._t(\"detail\", null, {\n      \"row\": row,\n      \"index\": index\n    }) : _vm._e()];\n  }), !_vm.visibleData.length ? _c('tr', {\n    staticClass: \"is-empty\"\n  }, [_c('td', {\n    attrs: {\n      \"colspan\": _vm.columnCount\n    }\n  }, [_vm._t(\"empty\")], 2)]) : _vm._e()], 2), _vm.$slots.footer !== undefined ? _c('tfoot', [_c('tr', {\n    staticClass: \"table-footer\"\n  }, [_vm.hasCustomFooterSlot() ? _vm._t(\"footer\") : _c('th', {\n    attrs: {\n      \"colspan\": _vm.columnCount\n    }\n  }, [_vm._t(\"footer\")], 2)], 2)]) : _vm._e()]), _vm.loading ? [_vm._t(\"loading\", [_c('b-loading', {\n    attrs: {\n      \"is-full-page\": false,\n      \"active\": _vm.loading\n    },\n    on: {\n      \"update:active\": function updateActive($event) {\n        _vm.loading = $event;\n      }\n    }\n  })])] : _vm._e()], 2), _vm.checkable && _vm.hasBottomLeftSlot() || _vm.paginated && (_vm.paginationPosition === 'bottom' || _vm.paginationPosition === 'both') ? [_vm._t(\"pagination\", [_c('b-table-pagination', _vm._b({\n    attrs: {\n      \"per-page\": _vm.perPage,\n      \"paginated\": _vm.paginated,\n      \"rounded\": _vm.paginationRounded,\n      \"icon-pack\": _vm.iconPack,\n      \"total\": _vm.newDataTotal,\n      \"current-page\": _vm.newCurrentPage,\n      \"aria-next-label\": _vm.ariaNextLabel,\n      \"aria-previous-label\": _vm.ariaPreviousLabel,\n      \"aria-page-label\": _vm.ariaPageLabel,\n      \"aria-current-label\": _vm.ariaCurrentLabel\n    },\n    on: {\n      \"update:currentPage\": function updateCurrentPage($event) {\n        _vm.newCurrentPage = $event;\n      },\n      \"update:current-page\": function updateCurrentPage($event) {\n        _vm.newCurrentPage = $event;\n      },\n      \"page-change\": function pageChange(event) {\n        return _vm.$emit('page-change', event);\n      }\n    }\n  }, 'b-table-pagination', _vm.$attrs, false), [_vm._t(\"bottom-left\")], 2)])] : _vm._e()], 2);\n};\n\nvar __vue_staticRenderFns__$2 = [];\n/* style */\n\nvar __vue_inject_styles__$3 = undefined;\n/* scoped */\n\nvar __vue_scope_id__$3 = undefined;\n/* module identifier */\n\nvar __vue_module_identifier__$3 = undefined;\n/* functional template */\n\nvar __vue_is_functional_template__$3 = false;\n/* style inject */\n\n/* style inject SSR */\n\nvar Table = __vue_normalize__({\n  render: __vue_render__$2,\n  staticRenderFns: __vue_staticRenderFns__$2\n}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, undefined, undefined);\n\nvar Plugin = {\n  install: function install(Vue) {\n    // individual import + extend method into Table.vue\n    if (typeof VueInstance === 'undefined') {\n      setVueInstance(Vue);\n    }\n\n    registerComponent(Vue, Table);\n    registerComponent(Vue, TableColumn);\n  }\n};\nuse(Plugin);\nexport default Plugin;\nexport { Table as BTable, TableColumn as BTableColumn };","map":null,"metadata":{},"sourceType":"module"}