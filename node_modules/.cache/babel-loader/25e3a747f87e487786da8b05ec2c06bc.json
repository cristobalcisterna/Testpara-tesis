{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { isArray, getEntries, normalizeXMLName, indent, stripHTML, assert, getKeys } from './utils';\nexport function _createFieldsMapper(fields) {\n  if (!fields || isArray(fields) && !fields.length || !isArray(fields) && !getKeys(fields).length) return function (item) {\n    return item;\n  };\n  var mapper = isArray(fields) ? fields.reduce(function (map, key) {\n    var _a;\n\n    return __assign(__assign({}, map), (_a = {}, _a[key] = key, _a));\n  }, Object.create(null)) : fields;\n  return function (item) {\n    if (isArray(item)) {\n      return item.map(function (i) {\n        return getEntries(i).reduce(function (map, _a) {\n          var _b = __read(_a, 2),\n              key = _b[0],\n              value = _b[1];\n\n          if (key in mapper) {\n            map[mapper[key]] = value;\n          }\n\n          return map;\n        }, Object.create(null));\n      }).filter(function (i) {\n        return getKeys(i).length;\n      });\n    }\n\n    return getEntries(item).reduce(function (map, _a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      if (key in mapper) {\n        map[mapper[key]] = value;\n      }\n\n      return map;\n    }, Object.create(null));\n  };\n}\nexport function _prepareData(data) {\n  var MESSAGE_VALID_JSON_FAIL = 'Invalid export data. Please provide a valid JSON';\n\n  try {\n    return typeof data === 'string' ? JSON.parse(data) : data;\n  } catch (_a) {\n    throw new Error(MESSAGE_VALID_JSON_FAIL);\n  }\n}\nexport function _createJSONData(data, replacer, space) {\n  if (replacer === void 0) {\n    replacer = null;\n  }\n\n  var MESSAGE_VALID_JSON_FAIL = 'Invalid export data. Please provide valid JSON object';\n\n  try {\n    return JSON.stringify(data, replacer, space);\n  } catch (_a) {\n    throw new Error(MESSAGE_VALID_JSON_FAIL);\n  }\n}\nexport function _createTableMap(data) {\n  return data.map(getEntries).reduce(function (tMap, rowKVs, rowIndex) {\n    return rowKVs.reduce(function (map, _a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      var columnValues = map[key] || Array.from({\n        length: data.length\n      }).map(function (_) {\n        return '';\n      });\n      columnValues[rowIndex] = (typeof value !== 'string' ? JSON.stringify(value) : value) || '';\n      map[key] = columnValues;\n      return map;\n    }, tMap);\n  }, Object.create(null));\n}\nexport function _createTableEntries(tableMap, beforeTableEncode) {\n  if (beforeTableEncode === void 0) {\n    beforeTableEncode = function beforeTableEncode(i) {\n      return i;\n    };\n  }\n\n  return beforeTableEncode(getEntries(tableMap).map(function (_a) {\n    var _b = __read(_a, 2),\n        fieldName = _b[0],\n        fieldValues = _b[1];\n\n    return {\n      fieldName: fieldName,\n      fieldValues: fieldValues\n    };\n  }));\n}\n\nfunction encloser(value) {\n  var enclosingCharacter = /,|\"|\\n/.test(value) ? '\"' : '';\n  var escaped = value.replace(/\"/g, '\"\"');\n  return \"\".concat(enclosingCharacter).concat(escaped).concat(enclosingCharacter);\n}\n\nexport function createCSVData(data, beforeTableEncode) {\n  if (beforeTableEncode === void 0) {\n    beforeTableEncode = function beforeTableEncode(i) {\n      return i;\n    };\n  }\n\n  if (!data.length) return '';\n\n  var tableMap = _createTableMap(data);\n\n  var tableEntries = _createTableEntries(tableMap, beforeTableEncode);\n\n  var head = tableEntries.map(function (_a) {\n    var fieldName = _a.fieldName;\n    return fieldName;\n  }).join(',') + '\\r\\n';\n  var columns = tableEntries.map(function (_a) {\n    var fieldValues = _a.fieldValues;\n    return fieldValues;\n  }).map(function (column) {\n    return column.map(encloser);\n  });\n  var rows = columns.reduce(function (mergedColumn, column) {\n    return mergedColumn.map(function (value, rowIndex) {\n      return \"\".concat(value, \",\").concat(column[rowIndex]);\n    });\n  });\n  return head + rows.join('\\r\\n');\n}\nexport function _renderTableHTMLText(data, beforeTableEncode) {\n  assert(data.length > 0);\n\n  var tableMap = _createTableMap(data);\n\n  var tableEntries = _createTableEntries(tableMap, beforeTableEncode);\n\n  var head = tableEntries.map(function (_a) {\n    var fieldName = _a.fieldName;\n    return fieldName;\n  }).join('</b></th><th><b>');\n  var columns = tableEntries.map(function (_a) {\n    var fieldValues = _a.fieldValues;\n    return fieldValues;\n  }).map(function (column) {\n    return column.map(function (value) {\n      return \"<td>\".concat(value, \"</td>\");\n    });\n  });\n  var rows = columns.reduce(function (mergedColumn, column) {\n    return mergedColumn.map(function (value, rowIndex) {\n      return \"\".concat(value).concat(column[rowIndex]);\n    });\n  });\n  return \"\\n    <table>\\n      <thead>\\n        <tr><th><b>\".concat(head, \"</b></th></tr>\\n      </thead>\\n      <tbody>\\n        <tr>\").concat(rows.join(\"</tr>\\n        <tr>\"), \"</tr>\\n      </tbody>\\n    </table>\\n  \");\n}\nexport function createXLSData(data, beforeTableEncode) {\n  if (beforeTableEncode === void 0) {\n    beforeTableEncode = function beforeTableEncode(i) {\n      return i;\n    };\n  }\n\n  if (!data.length) return '';\n  var content = \"<html>\\n  <head>\\n    <meta charset=\\\"UTF-8\\\" />\\n  </head >\\n  <body>\\n    \".concat(_renderTableHTMLText(data, beforeTableEncode), \"\\n  </body>\\n</html >\\n\");\n  return content;\n}\nexport function createXMLData(data) {\n  var content = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><!DOCTYPE base>\\n\".concat(_renderXML(data, 'base'), \"\\n\");\n  return content;\n}\n\nfunction _renderXML(data, tagName, arrayElementTag, spaces) {\n  if (arrayElementTag === void 0) {\n    arrayElementTag = 'element';\n  }\n\n  if (spaces === void 0) {\n    spaces = 0;\n  }\n\n  var tag = normalizeXMLName(tagName);\n  var indentSpaces = indent(spaces);\n\n  if (data === null || data === undefined) {\n    return \"\".concat(indentSpaces, \"<\").concat(tag, \" />\");\n  }\n\n  var content = isArray(data) ? data.map(function (item) {\n    return _renderXML(item, arrayElementTag, arrayElementTag, spaces + 2);\n  }).join('\\n') : _typeof(data) === 'object' ? getEntries(data).map(function (_a) {\n    var _b = __read(_a, 2),\n        key = _b[0],\n        value = _b[1];\n\n    return _renderXML(value, key, arrayElementTag, spaces + 2);\n  }).join('\\n') : indentSpaces + '  ' + stripHTML(String(data));\n  var contentWithWrapper = \"\".concat(indentSpaces, \"<\").concat(tag, \">\\n\").concat(content, \"\\n\").concat(indentSpaces, \"</\").concat(tag, \">\");\n  return contentWithWrapper;\n}","map":null,"metadata":{},"sourceType":"module"}